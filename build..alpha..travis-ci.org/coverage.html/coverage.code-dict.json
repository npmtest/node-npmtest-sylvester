{"/home/travis/build/npmtest/node-npmtest-sylvester/test.js":"/* istanbul instrument in package npmtest_sylvester */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-sylvester/lib.npmtest_sylvester.js":"/* istanbul instrument in package npmtest_sylvester */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_sylvester = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_sylvester = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-sylvester/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-sylvester && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_sylvester */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_sylvester\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_sylvester.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_sylvester.rollup.js'] =\n            local.assetsDict['/assets.npmtest_sylvester.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_sylvester.__dirname + '/lib.npmtest_sylvester.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-sylvester/node_modules/sylvester/lib/node-sylvester/index.js":"// Copyright (c) 2011, Chris Umbel\n\nexports.Vector = require('./vector');\nglobal.$V = exports.Vector.create;\nexports.Matrix = require('./matrix');\nglobal.$M = exports.Matrix.create;\nexports.Line = require('./line');\nglobal.$L = exports.Line.create;\nexports.Plane = require('./plane');\nglobal.$P = exports.Plane.create;\nexports.Line.Segment = require('./line.segment');\nexports.Sylvester = require('./sylvester');\n","/home/travis/build/npmtest/node-npmtest-sylvester/node_modules/sylvester/lib/node-sylvester/vector.js":"// Copyright (c) 2011, Chris Umbel, James Coglan\n// This file is required in order for any other classes to work. Some Vector methods work with the\n// other Sylvester classes and are useless unless they are included. Other classes such as Line and\n// Plane will not function at all without Vector being loaded first.\n\nvar Sylvester = require('./sylvester'),\nMatrix = require('./matrix');\n\nfunction Vector() {}\nVector.prototype = {\n\n    norm: function() {\n\tvar n = this.elements.length;\n\tvar sum = 0;\n\n\twhile (n--) {\n\t    sum += Math.pow(this.elements[n], 2);\n\t}\n\n\treturn Math.sqrt(sum);\n    },\n\n    // Returns element i of the vector\n    e: function(i) {\n      return (i < 1 || i > this.elements.length) ? null : this.elements[i - 1];\n    },\n\n    // Returns the number of rows/columns the vector has\n    dimensions: function() {\n      return {rows: 1, cols: this.elements.length};\n    },\n\n    // Returns the number of rows in the vector\n    rows: function() {\n      return 1;\n    },\n\n    // Returns the number of columns in the vector\n    cols: function() {\n      return this.elements.length;\n    },\n\n    // Returns the modulus ('length') of the vector\n    modulus: function() {\n      return Math.sqrt(this.dot(this));\n    },\n\n    // Returns true iff the vector is equal to the argument\n    eql: function(vector) {\n    \tvar n = this.elements.length;\n    \tvar V = vector.elements || vector;\n    \tif (n != V.length) { return false; }\n    \twhile (n--) {\n    \t    if (Math.abs(this.elements[n] - V[n]) > Sylvester.precision) { return false; }\n    \t}\n    \treturn true;\n    },\n\n    // Returns a copy of the vector\n    dup: function() {\n\t    return Vector.create(this.elements);\n    },\n\n    // Maps the vector to another vector according to the given function\n    map: function(fn) {\n\tvar elements = [];\n\tthis.each(function(x, i) {\n\t    elements.push(fn(x, i));\n\t});\n\treturn Vector.create(elements);\n    },\n\n    // Calls the iterator for each element of the vector in turn\n    each: function(fn) {\n\tvar n = this.elements.length;\n\tfor (var i = 0; i < n; i++) {\n\t    fn(this.elements[i], i + 1);\n\t}\n    },\n\n    // Returns a new vector created by normalizing the receiver\n    toUnitVector: function() {\n\tvar r = this.modulus();\n\tif (r === 0) { return this.dup(); }\n\treturn this.map(function(x) { return x / r; });\n    },\n\n    // Returns the angle between the vector and the argument (also a vector)\n    angleFrom: function(vector) {\n\tvar V = vector.elements || vector;\n\tvar n = this.elements.length, k = n, i;\n\tif (n != V.length) { return null; }\n\tvar dot = 0, mod1 = 0, mod2 = 0;\n\t// Work things out in parallel to save time\n\tthis.each(function(x, i) {\n\t    dot += x * V[i - 1];\n\t    mod1 += x * x;\n\t    mod2 += V[i - 1] * V[i - 1];\n\t});\n\tmod1 = Math.sqrt(mod1); mod2 = Math.sqrt(mod2);\n\tif (mod1 * mod2 === 0) { return null; }\n\tvar theta = dot / (mod1 * mod2);\n\tif (theta < -1) { theta = -1; }\n\tif (theta > 1) { theta = 1; }\n\treturn Math.acos(theta);\n    },\n\n    // Returns true iff the vector is parallel to the argument\n    isParallelTo: function(vector) {\n\tvar angle = this.angleFrom(vector);\n\treturn (angle === null) ? null : (angle <= Sylvester.precision);\n    },\n\n    // Returns true iff the vector is antiparallel to the argument\n    isAntiparallelTo: function(vector) {\n\tvar angle = this.angleFrom(vector);\n\treturn (angle === null) ? null : (Math.abs(angle - Math.PI) <= Sylvester.precision);\n    },\n\n    // Returns true iff the vector is perpendicular to the argument\n    isPerpendicularTo: function(vector) {\n\tvar dot = this.dot(vector);\n\treturn (dot === null) ? null : (Math.abs(dot) <= Sylvester.precision);\n    },\n\n    // Returns the result of adding the argument to the vector\n    add: function(value) {\n\tvar V = value.elements || value;\n\n\tif (this.elements.length != V.length) \n\t    return this.map(function(v) { return v + value });\n\telse\n\t    return this.map(function(x, i) { return x + V[i - 1]; });\n    },\n\n    // Returns the result of subtracting the argument from the vector\n    subtract: function(v) {\n\tif (typeof(v) == 'number')\n\t    return this.map(function(k) { return k - v; });\n\n\tvar V = v.elements || v;\n\tif (this.elements.length != V.length) { return null; }\n\treturn this.map(function(x, i) { return x - V[i - 1]; });\n    },\n\n    // Returns the result of multiplying the elements of the vector by the argument\n    multiply: function(k) {\n\treturn this.map(function(x) { return x * k; });\n    },\n\n    elementMultiply: function(v) {\n\treturn this.map(function(k, i) {\n\t    return v.e(i) * k;\n\t});\n    },\n\n    sum: function() {\n\tvar sum = 0;\n\tthis.map(function(x) { sum += x;});\n\treturn sum;\n    },\n\n    chomp: function(n) {\n\tvar elements = [];\n\n\tfor (var i = n; i < this.elements.length; i++) {\n\t    elements.push(this.elements[i]);\n\t}\n\n\treturn Vector.create(elements);\n    },\n\n    top: function(n) {\n\tvar elements = [];\n\n\tfor (var i = 0; i < n; i++) {\n\t    elements.push(this.elements[i]);\n\t}\n\n\treturn Vector.create(elements);\n    },\n\n    augment: function(elements) {\n\tvar newElements = this.elements;\n\n\tfor (var i = 0; i < elements.length; i++) {\n\t    newElements.push(elements[i]);\n\t}\n\n\treturn Vector.create(newElements);\n    },\n\n    x: function(k) { return this.multiply(k); },\n\n    log: function() {\n\treturn Vector.log(this);\n    },\n\n    elementDivide: function(vector) {\n\treturn this.map(function(v, i) {\n\t    return v / vector.e(i);\n\t});\n    },\n\n    product: function() {\n\tvar p = 1;\n\n\tthis.map(function(v) {\n\t    p *= v;\n\t});\n\n\treturn p;\n    },\n\n    // Returns the scalar product of the vector with the argument\n    // Both vectors must have equal dimensionality\n    dot: function(vector) {\n\tvar V = vector.elements || vector;\n\tvar i, product = 0, n = this.elements.length;\t\n\tif (n != V.length) { return null; }\n\twhile (n--) { product += this.elements[n] * V[n]; }\n\treturn product;\n    },\n\n    // Returns the vector product of the vector with the argument\n    // Both vectors must have dimensionality 3\n    cross: function(vector) {\n\tvar B = vector.elements || vector;\n\tif (this.elements.length != 3 || B.length != 3) { return null; }\n\tvar A = this.elements;\n\treturn Vector.create([\n\t    (A[1] * B[2]) - (A[2] * B[1]),\n\t    (A[2] * B[0]) - (A[0] * B[2]),\n\t    (A[0] * B[1]) - (A[1] * B[0])\n\t]);\n    },\n\n    // Returns the (absolute) largest element of the vector\n    max: function() {\n\tvar m = 0, i = this.elements.length;\n\twhile (i--) {\n\t    if (Math.abs(this.elements[i]) > Math.abs(m)) { m = this.elements[i]; }\n\t}\n\treturn m;\n    },\n\n\n    maxIndex: function() {\n\tvar m = 0, i = this.elements.length;\n\tvar maxIndex = -1;\n\n\twhile (i--) {\n\t    if (Math.abs(this.elements[i]) > Math.abs(m)) { \n\t\tm = this.elements[i]; \n\t\tmaxIndex = i + 1;\n\t    }\n\t}\n\n\treturn maxIndex;\n    },\n\n\n    // Returns the index of the first match found\n    indexOf: function(x) {\n\tvar index = null, n = this.elements.length;\n\tfor (var i = 0; i < n; i++) {\n\t    if (index === null && this.elements[i] == x) {\n\t\tindex = i + 1;\n\t    }\n\t}\n\treturn index;\n    },\n\n    // Returns a diagonal matrix with the vector's elements as its diagonal elements\n    toDiagonalMatrix: function() {\n\treturn Matrix.Diagonal(this.elements);\n    },\n\n    // Returns the result of rounding the elements of the vector\n    round: function() {\n\treturn this.map(function(x) { return Math.round(x); });\n    },\n\n    // Transpose a Vector, return a 1xn Matrix\n    transpose: function() {\n\tvar rows = this.elements.length;\n\tvar elements = [];\n\n\tfor (var i = 0; i < rows; i++) {\n\t    elements.push([this.elements[i]]);\n\t}\n\treturn Matrix.create(elements);\n    },\n\n    // Returns a copy of the vector with elements set to the given value if they\n    // differ from it by less than Sylvester.precision\n    snapTo: function(x) {\n\treturn this.map(function(y) {\n\t    return (Math.abs(y - x) <= Sylvester.precision) ? x : y;\n\t});\n    },\n\n    // Returns the vector's distance from the argument, when considered as a point in space\n    distanceFrom: function(obj) {\n\tif (obj.anchor || (obj.start && obj.end)) { return obj.distanceFrom(this); }\n\tvar V = obj.elements || obj;\n\tif (V.length != this.elements.length) { return null; }\n\tvar sum = 0, part;\n\tthis.each(function(x, i) {\n\t    part = x - V[i - 1];\n\t    sum += part * part;\n\t});\n\treturn Math.sqrt(sum);\n    },\n\n    // Returns true if the vector is point on the given line\n    liesOn: function(line) {\n\treturn line.contains(this);\n    },\n\n    // Return true iff the vector is a point in the given plane\n    liesIn: function(plane) {\n\treturn plane.contains(this);\n    },\n\n    // Rotates the vector about the given object. The object should be a\n    // point if the vector is 2D, and a line if it is 3D. Be careful with line directions!\n    rotate: function(t, obj) {\n\tvar V, R = null, x, y, z;\n\tif (t.determinant) { R = t.elements; }\n\tswitch (this.elements.length) {\n\tcase 2:\n            V = obj.elements || obj;\n            if (V.length != 2) { return null; }\n            if (!R) { R = Matrix.Rotation(t).elements; }\n            x = this.elements[0] - V[0];\n            y = this.elements[1] - V[1];\n            return Vector.create([\n\t\tV[0] + R[0][0] * x + R[0][1] * y,\n\t\tV[1] + R[1][0] * x + R[1][1] * y\n            ]);\n            break;\n\tcase 3:\n            if (!obj.direction) { return null; }\n            var C = obj.pointClosestTo(this).elements;\n            if (!R) { R = Matrix.Rotation(t, obj.direction).elements; }\n            x = this.elements[0] - C[0];\n            y = this.elements[1] - C[1];\n            z = this.elements[2] - C[2];\n            return Vector.create([\n\t\tC[0] + R[0][0] * x + R[0][1] * y + R[0][2] * z,\n\t\tC[1] + R[1][0] * x + R[1][1] * y + R[1][2] * z,\n\t\tC[2] + R[2][0] * x + R[2][1] * y + R[2][2] * z\n            ]);\n            break;\n\tdefault:\n            return null;\n\t}\n    },\n\n    // Returns the result of reflecting the point in the given point, line or plane\n    reflectionIn: function(obj) {\n\tif (obj.anchor) {\n\t    // obj is a plane or line\n\t    var P = this.elements.slice();\n\t    var C = obj.pointClosestTo(P).elements;\n\t    return Vector.create([C[0] + (C[0] - P[0]), C[1] + (C[1] - P[1]), C[2] + (C[2] - (P[2] || 0))]);\n\t} else {\n\t    // obj is a point\n\t    var Q = obj.elements || obj;\n\t    if (this.elements.length != Q.length) { return null; }\n\t    return this.map(function(x, i) { return Q[i - 1] + (Q[i - 1] - x); });\n\t}\n    },\n\n    // Utility to make sure vectors are 3D. If they are 2D, a zero z-component is added\n    to3D: function() {\n\tvar V = this.dup();\n\tswitch (V.elements.length) {\n\tcase 3: break;\n\tcase 2: V.elements.push(0); break;\n\tdefault: return null;\n\t}\n\treturn V;\n    },\n\n    // Returns a string representation of the vector\n    inspect: function() {\n\treturn '[' + this.elements.join(', ') + ']';\n    },\n\n    // Set vector's elements from an array\n    setElements: function(els) {\n\tthis.elements = (els.elements || els).slice();\n\treturn this;\n    }\n};\n\n// Constructor function\nVector.create = function(elements) {\n    var V = new Vector();\n    return V.setElements(elements);\n};\n\n// i, j, k unit vectors\nVector.i = Vector.create([1, 0, 0]);\nVector.j = Vector.create([0, 1, 0]);\nVector.k = Vector.create([0, 0, 1]);\n\n// Random vector of size n\nVector.Random = function(n) {\n    var elements = [];\n    while (n--) { elements.push(Math.random()); }\n    return Vector.create(elements);\n};\n\nVector.Fill = function(n, v) {\n    var elements = [];\n    while (n--) { elements.push(v); }\n    return Vector.create(elements);\n};\n\n// Vector filled with zeros\nVector.Zero = function(n) {\n    return Vector.Fill(n, 0);\n};\n\nVector.One = function(n) {\n    return Vector.Fill(n, 1);\n};\n\nVector.log = function(v) {\n    return v.map(function(x) {\n\treturn Math.log(x);\n    });\n};\n\nmodule.exports = Vector;\n","/home/travis/build/npmtest/node-npmtest-sylvester/node_modules/sylvester/lib/node-sylvester/sylvester.js":"// Copyright (c) 2011, Chris Umbel, James Coglan\n// This file is required in order for any other classes to work. Some Vector methods work with the\n// other Sylvester classes and are useless unless they are included. Other classes such as Line and\n// Plane will not function at all without Vector being loaded first.           \n\nMath.sign = function(x) {\n    return x < 0 ? -1: 1;\n}\n                                              \nvar Sylvester = {\n    precision: 1e-6,\n    approxPrecision: 1e-5\n};\n\nmodule.exports = Sylvester;\n","/home/travis/build/npmtest/node-npmtest-sylvester/node_modules/sylvester/lib/node-sylvester/matrix.js":"// Copyright (c) 2011, Chris Umbel, James Coglan\n// Matrix class - depends on Vector.\n\nvar fs = require('fs');\nvar Sylvester = require('./sylvester');\nvar Vector = require('./vector');\n\n// augment a matrix M with identity rows/cols\nfunction identSize(M, m, n, k) {\n    var e = M.elements;\n    var i = k - 1;\n\n    while(i--) {\n\tvar row = [];\n\t\n\tfor(var j = 0; j < n; j++)\n\t    row.push(j == i ? 1 : 0);\n\t\n        e.unshift(row);\n    }\n    \n    for(var i = k - 1; i < m; i++) {\n        while(e[i].length < n)\n            e[i].unshift(0);\n    }\n\n    return $M(e);\n}\n\nfunction pca(X) {\n    var Sigma = X.transpose().x(X).x(1 / X.rows());\n    var svd = Sigma.svd();\n    return {U: svd.U, S: svd.S};\n}\n\n// singular value decomposition in pure javascript\nfunction svdJs() {\n    var A = this;\n    var V = Matrix.I(A.rows());\n    var S = A.transpose();\n    var U = Matrix.I(A.cols());\n    var err = Number.MAX_VALUE;\n    var i = 0;\n    var maxLoop = 100;\n\n    while(err > 2.2737e-13 && i < maxLoop) {\n        var qr = S.transpose().qrJs();\n        S = qr.R;\n        V = V.x(qr.Q);\n        qr = S.transpose().qrJs();\n        U = U.x(qr.Q);\n        S = qr.R;\n\n        var e = S.triu(1).unroll().norm();\n        var f = S.diagonal().norm();\n\n        if(f == 0)\n            f = 1;\n\n        err = e / f;\n\n        i++;\n    }\n\n    var ss = S.diagonal();\n    var s = [];\n\n    for(var i = 1; i <= ss.cols(); i++) {\n        var ssn = ss.e(i);\n        s.push(Math.abs(ssn));\n\n        if(ssn < 0) {\n            for(var j = 0; j < U.rows(); j++) {\n                V.elements[j][i - 1] = -(V.elements[j][i - 1]);\n            }\n        }\n    }\n\n    return {U: U, S: $V(s).toDiagonalMatrix(), V: V};\n}\n\n// singular value decomposition using LAPACK\nfunction svdPack() {\n    var result = lapack.sgesvd('A', 'A', this.elements);\n\n    return {\n        U: $M(result.U),\n        S: $M(result.S).column(1).toDiagonalMatrix(),\n\tV: $M(result.VT).transpose()\n    };\n}\n\n// QR decomposition in pure javascript\nfunction qrJs() {\n    var m = this.rows();\n    var n = this.cols();\n    var Q = Matrix.I(m);\n    var A = this;\n    \n    for(var k = 1; k < Math.min(m, n); k++) {\n\tvar ak = A.slice(k, 0, k, k).col(1);\n\tvar oneZero = [1];\n\t\n\twhile(oneZero.length <=  m - k)\n\t    oneZero.push(0);\n\t\n\toneZero = $V(oneZero);\n\tvar vk = ak.add(oneZero.x(ak.norm() * Math.sign(ak.e(1))));\n\tvar Vk = $M(vk);\n\tvar Hk = Matrix.I(m - k + 1).subtract(Vk.x(2).x(Vk.transpose()).div(Vk.transpose().x(Vk).e(1, 1)));\n\tvar Qk = identSize(Hk, m, n, k);\n\tA = Qk.x(A);\n\t// slow way to compute Q\n\tQ = Q.x(Qk);\n    }\n    \n    return {Q: Q, R: A};\n}\n\n// QR decomposition using LAPACK\nfunction qrPack() {\n    var qr = lapack.qr(this.elements);\n\n    return {\n\tQ: $M(qr.Q),\n\tR: $M(qr.R)\n    };\n}\n\nfunction Matrix() {}\nMatrix.prototype = {\n    // solve a system of linear equations (work in progress)\n    solve: function(b) {\n\tvar lu = this.lu();\n\tb = lu.P.x(b);\n\tvar y = lu.L.forwardSubstitute(b);\n\tvar x = lu.U.backSubstitute(y);\n\treturn lu.P.x(x);\n\t//return this.inv().x(b);\n    },\n\n    // project a matrix onto a lower dim\n    pcaProject: function(k, U) {\n\tvar U = U || pca(this).U;\n\tvar Ureduce= U.slice(1, U.rows(), 1, k);\n\treturn {Z: this.x(Ureduce), U: U};\n    },\n\n    // recover a matrix to a higher dimension\n    pcaRecover: function(U) {\n\tvar k = this.cols();\n\tvar Ureduce = U.slice(1, U.rows(), 1, k);\n\treturn this.x(Ureduce.transpose());\n    },    \n\n    // grab the upper triangular part of the matrix\n    triu: function(k) {\n\tif(!k)\n\t    k = 0;\n\t\n\treturn this.map(function(x, i, j) {\n\t    return j - i >= k ? x : 0;\n\t});\n    },\n\n    // unroll a matrix into a vector\n    unroll: function() {\n\tvar v = [];\n\t\n\tfor(var i = 1; i <= this.cols(); i++) {\n\t    for(var j = 1; j <= this.rows(); j++) {\n\t\tv.push(this.e(j, i));\n\t    }\n\t}\n\n\treturn $V(v);\n    },\n\n    // return a sub-block of the matrix\n    slice: function(startRow, endRow, startCol, endCol) {\n\tvar x = [];\n\t\n\tif(endRow == 0)\n\t    endRow = this.rows();\n\t\n\tif(endCol == 0)\n\t    endCol = this.cols();\n\n\tfor(i = startRow; i <= endRow; i++) {\n\t    var row = [];\n\n\t    for(j = startCol; j <= endCol; j++) {\n\t\trow.push(this.e(i, j));\n\t    }\n\n\t    x.push(row);\n\t}\n\n\treturn $M(x);\n    },\n\n    // Returns element (i,j) of the matrix\n    e: function(i,j) {\n\tif (i < 1 || i > this.elements.length || j < 1 || j > this.elements[0].length) { return null; }\n\treturn this.elements[i - 1][j - 1];\n    },\n\n    // Returns row k of the matrix as a vector\n    row: function(i) {\n\tif (i > this.elements.length) { return null; }\n\treturn $V(this.elements[i - 1]);\n    },\n\n    // Returns column k of the matrix as a vector\n    col: function(j) {\n\tif (j > this.elements[0].length) { return null; }\n\tvar col = [], n = this.elements.length;\n\tfor (var i = 0; i < n; i++) { col.push(this.elements[i][j - 1]); }\n\treturn $V(col);\n    },\n\n    // Returns the number of rows/columns the matrix has\n    dimensions: function() {\n\treturn {rows: this.elements.length, cols: this.elements[0].length};\n    },\n\n    // Returns the number of rows in the matrix\n    rows: function() {\n\treturn this.elements.length;\n    },\n\n    // Returns the number of columns in the matrix\n    cols: function() {\n\treturn this.elements[0].length;\n    },\n\n    approxEql: function(matrix) {\n\treturn this.eql(matrix, Sylvester.approxPrecision);\n    },\n\n    // Returns true iff the matrix is equal to the argument. You can supply\n    // a vector as the argument, in which case the receiver must be a\n    // one-column matrix equal to the vector.\n    eql: function(matrix, precision) {\n\tvar M = matrix.elements || matrix;\n\tif (typeof(M[0][0]) == 'undefined') { M = Matrix.create(M).elements; }\n\tif (this.elements.length != M.length ||\n            this.elements[0].length != M[0].length) { return false; }\n\tvar i = this.elements.length, nj = this.elements[0].length, j;\n\twhile (i--) { j = nj;\n\t\t      while (j--) {\n\t\t\t  if (Math.abs(this.elements[i][j] - M[i][j]) > (precision || Sylvester.precision)) { return false; }\n\t\t      }\n\t\t    }\n\treturn true;\n    },\n\n    // Returns a copy of the matrix\n    dup: function() {\n\treturn Matrix.create(this.elements);\n    },\n\n    // Maps the matrix to another matrix (of the same dimensions) according to the given function\n    map: function(fn) {\n    var els = [], i = this.elements.length, nj = this.elements[0].length, j;\n\twhile (i--) { j = nj;\n\t\t      els[i] = [];\n\t\t      while (j--) {\n\t\t\t  els[i][j] = fn(this.elements[i][j], i + 1, j + 1);\n\t\t      }\n\t\t    }\n\treturn Matrix.create(els);\n    },\n\n    // Returns true iff the argument has the same dimensions as the matrix\n    isSameSizeAs: function(matrix) {\n\tvar M = matrix.elements || matrix;\n\tif (typeof(M[0][0]) == 'undefined') { M = Matrix.create(M).elements; }\n\treturn (this.elements.length == M.length &&\n\t\tthis.elements[0].length == M[0].length);\n    },\n\n    // Returns the result of adding the argument to the matrix\n    add: function(matrix) {\n\tif(typeof(matrix) == 'number') {\n\t    return this.map(function(x, i, j) { return x + matrix});\n\t} else {\n\t    var M = matrix.elements || matrix;\n\t    if (typeof(M[0][0]) == 'undefined') { M = Matrix.create(M).elements; }\n\t    if (!this.isSameSizeAs(M)) { return null; }\n\t    return this.map(function(x, i, j) { return x + M[i - 1][j - 1]; });\n\t}\n    },\n\n    // Returns the result of subtracting the argument from the matrix\n    subtract: function(matrix) {\n\tif(typeof(matrix) == 'number') {\n\t    return this.map(function(x, i, j) { return x - matrix});\n\t} else {\n\t    var M = matrix.elements || matrix;\n\t    if (typeof(M[0][0]) == 'undefined') { M = Matrix.create(M).elements; }\n\t    if (!this.isSameSizeAs(M)) { return null; }\n\t    return this.map(function(x, i, j) { return x - M[i - 1][j - 1]; });\n\t}\n    },\n\n    // Returns true iff the matrix can multiply the argument from the left\n    canMultiplyFromLeft: function(matrix) {\n\tvar M = matrix.elements || matrix;\n\tif (typeof(M[0][0]) == 'undefined') { M = Matrix.create(M).elements; }\n\t// this.columns should equal matrix.rows\n\treturn (this.elements[0].length == M.length);\n    },\n\n    // Returns the result of a multiplication-style operation the matrix from the right by the argument.\n    // If the argument is a scalar then just operate on all the elements. If the argument is\n    // a vector, a vector is returned, which saves you having to remember calling\n    // col(1) on the result.\n    mulOp: function(matrix, op) {\n\tif (!matrix.elements) {\n\t    return this.map(function(x) { return op(x, matrix); });\n\t}\n\n\tvar returnVector = matrix.modulus ? true : false;\n\tvar M = matrix.elements || matrix;\n\tif (typeof(M[0][0]) == 'undefined') \n\t    M = Matrix.create(M).elements;\n\tif (!this.canMultiplyFromLeft(M)) \n\t    return null; \n\tvar e = this.elements, rowThis, rowElem, elements = [],\n        sum, m = e.length, n = M[0].length, o = e[0].length, i = m, j, k;\n\n\twhile (i--) {\n            rowElem = [];\n            rowThis = e[i];\n            j = n;\n\n            while (j--) {\n\t\tsum = 0;\n\t\tk = o;\n\n\t\twhile (k--) {\n                    sum += op(rowThis[k], M[k][j]);\n\t\t}\n\n\t\trowElem[j] = sum;\n            }\n\n            elements[i] = rowElem;\n\t}\n\n\tvar M = Matrix.create(elements);\n\treturn returnVector ? M.col(1) : M;\n    },\n\n    // Returns the result of dividing the matrix from the right by the argument.\n    // If the argument is a scalar then just divide all the elements. If the argument is\n    // a vector, a vector is returned, which saves you having to remember calling\n    // col(1) on the result.\n    div: function(matrix) {\n\treturn this.mulOp(matrix, function(x, y) { return x / y});\n    },\n\n    // Returns the result of multiplying the matrix from the right by the argument.\n    // If the argument is a scalar then just multiply all the elements. If the argument is\n    // a vector, a vector is returned, which saves you having to remember calling\n    // col(1) on the result.\n    multiply: function(matrix) {\n\treturn this.mulOp(matrix, function(x, y) { return x * y});\n    },\n\n    x: function(matrix) { return this.multiply(matrix); },\n\n    elementMultiply: function(v) {\n        return this.map(function(k, i, j) {\n            return v.e(i, j) * k;\n        });\n    },\n\n    // sum all elements in the matrix\n    sum: function() {\n        var sum = 0;\n\n        this.map(function(x) { sum += x;});\n\n        return sum;\n    },\n\n    // Returns a Vector of each colum averaged.\n    mean: function() {\n      var dim = this.dimensions();\n      var r = [];\n      for (var i = 1; i <= dim.cols; i++) {\n        r.push(this.col(i).sum() / dim.rows);\n      }\n      return $V(r);\n    },\n\n    column: function(n) {\n\treturn this.col(n);\n    },\n\n    // element-wise log\n    log: function() {\n\treturn this.map(function(x) { return Math.log(x); });\n    },\n\n    // Returns a submatrix taken from the matrix\n    // Argument order is: start row, start col, nrows, ncols\n    // Element selection wraps if the required index is outside the matrix's bounds, so you could\n    // use this to perform row/column cycling or copy-augmenting.\n    minor: function(a, b, c, d) {\n\tvar elements = [], ni = c, i, nj, j;\n\tvar rows = this.elements.length, cols = this.elements[0].length;\n\twhile (ni--) {\n\t    i = c - ni - 1;\n\t    elements[i] = [];\n\t    nj = d;\n\t    while (nj--) {\n\t\tj = d - nj - 1;\n\t\telements[i][j] = this.elements[(a + i - 1) % rows][(b + j - 1) % cols];\n\t    }\n\t}\n\treturn Matrix.create(elements);\n    },\n\n    // Returns the transpose of the matrix\n    transpose: function() {\n    var rows = this.elements.length, i, cols = this.elements[0].length, j;\n\tvar elements = [], i = cols;\n\twhile (i--) {\n\t    j = rows;\n\t    elements[i] = [];\n\t    while (j--) {\n\t\telements[i][j] = this.elements[j][i];\n\t    }\n\t}\n\treturn Matrix.create(elements);\n    },\n\n    // Returns true iff the matrix is square\n    isSquare: function() {\n\treturn (this.elements.length == this.elements[0].length);\n    },\n\n    // Returns the (absolute) largest element of the matrix\n    max: function() {\n\tvar m = 0, i = this.elements.length, nj = this.elements[0].length, j;\n\twhile (i--) {\n\t    j = nj;\n\t    while (j--) {\n\t\tif (Math.abs(this.elements[i][j]) > Math.abs(m)) { m = this.elements[i][j]; }\n\t    }\n\t}\n\treturn m;\n    },\n\n    // Returns the indeces of the first match found by reading row-by-row from left to right\n    indexOf: function(x) {\n\tvar index = null, ni = this.elements.length, i, nj = this.elements[0].length, j;\n\tfor (i = 0; i < ni; i++) {\n\t    for (j = 0; j < nj; j++) {\n\t\tif (this.elements[i][j] == x) { return {i: i + 1, j: j + 1}; }\n\t    }\n\t}\n\treturn null;\n    },\n\n    // If the matrix is square, returns the diagonal elements as a vector.\n    // Otherwise, returns null.\n    diagonal: function() {\n\tif (!this.isSquare) { return null; }\n\tvar els = [], n = this.elements.length;\n\tfor (var i = 0; i < n; i++) {\n\t    els.push(this.elements[i][i]);\n\t}\n\treturn $V(els);\n    },\n\n    // Make the matrix upper (right) triangular by Gaussian elimination.\n    // This method only adds multiples of rows to other rows. No rows are\n    // scaled up or switched, and the determinant is preserved.\n    toRightTriangular: function() {\n\tvar M = this.dup(), els;\n\tvar n = this.elements.length, i, j, np = this.elements[0].length, p;\n\tfor (i = 0; i < n; i++) {\n\t    if (M.elements[i][i] == 0) {\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t    if (M.elements[j][i] != 0) {\n\t\t\tels = [];\n\t\t\tfor (p = 0; p < np; p++) { els.push(M.elements[i][p] + M.elements[j][p]); }\n\t\t\tM.elements[i] = els;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    if (M.elements[i][i] != 0) {\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t    var multiplier = M.elements[j][i] / M.elements[i][i];\n\t\t    els = [];\n\t\t    for (p = 0; p < np; p++) {\n\t\t\t// Elements with column numbers up to an including the number\n\t\t\t// of the row that we're subtracting can safely be set straight to\n\t\t\t// zero, since that's the point of this routine and it avoids having\n\t\t\t// to loop over and correct rounding errors later\n\t\t\tels.push(p <= i ? 0 : M.elements[j][p] - M.elements[i][p] * multiplier);\n\t\t    }\n\t\t    M.elements[j] = els;\n\t\t}\n\t    }\n\t}\n\treturn M;\n    },\n\n    toUpperTriangular: function() { return this.toRightTriangular(); },\n\n    // Returns the determinant for square matrices\n    determinant: function() {\n\tif (!this.isSquare()) { return null; }\n\tif (this.cols == 1 && this.rows == 1) { return this.row(1); }\n\tif (this.cols == 0 && this.rows == 0) { return 1; }\n\tvar M = this.toRightTriangular();\n\tvar det = M.elements[0][0], n = M.elements.length;\n\tfor (var i = 1; i < n; i++) {\n\t    det = det * M.elements[i][i];\n\t}\n\treturn det;\n    },\n    det: function() { return this.determinant(); },\n\n    // Returns true iff the matrix is singular\n    isSingular: function() {\n\treturn (this.isSquare() && this.determinant() === 0);\n    },\n\n    // Returns the trace for square matrices\n    trace: function() {\n\tif (!this.isSquare()) { return null; }\n\tvar tr = this.elements[0][0], n = this.elements.length;\n\tfor (var i = 1; i < n; i++) {\n\t    tr += this.elements[i][i];\n\t}\n\treturn tr;\n    },\n\n    tr: function() { return this.trace(); },\n\n    // Returns the rank of the matrix\n    rank: function() {\n\tvar M = this.toRightTriangular(), rank = 0;\n\tvar i = this.elements.length, nj = this.elements[0].length, j;\n\twhile (i--) {\n\t    j = nj;\n\t    while (j--) {\n\t\tif (Math.abs(M.elements[i][j]) > Sylvester.precision) { rank++; break; }\n\t    }\n\t}\n\treturn rank;\n    },\n\n    rk: function() { return this.rank(); },\n\n    // Returns the result of attaching the given argument to the right-hand side of the matrix\n    augment: function(matrix) {\n\tvar M = matrix.elements || matrix;\n\tif (typeof(M[0][0]) == 'undefined') { M = Matrix.create(M).elements; }\n\tvar T = this.dup(), cols = T.elements[0].length;\n\tvar i = T.elements.length, nj = M[0].length, j;\n\tif (i != M.length) { return null; }\n\twhile (i--) {\n\t    j = nj;\n\t    while (j--) {\n\t\tT.elements[i][cols + j] = M[i][j];\n\t    }\n\t}\n\treturn T;\n    },\n\n    // Returns the inverse (if one exists) using Gauss-Jordan\n    inverse: function() {\n\tif (!this.isSquare() || this.isSingular()) { return null; }\n\tvar n = this.elements.length, i = n, j;\n\tvar M = this.augment(Matrix.I(n)).toRightTriangular();\n\tvar np = M.elements[0].length, p, els, divisor;\n\tvar inverse_elements = [], new_element;\n\t// Matrix is non-singular so there will be no zeros on the diagonal\n\t// Cycle through rows from last to first\n\twhile (i--) {\n\t    // First, normalise diagonal elements to 1\n\t    els = [];\n\t    inverse_elements[i] = [];\n\t    divisor = M.elements[i][i];\n\t    for (p = 0; p < np; p++) {\n        new_element = M.elements[i][p] / divisor;\n\t\tels.push(new_element);\n\t\t// Shuffle off the current row of the right hand side into the results\n\t\t// array as it will not be modified by later runs through this loop\n\t\tif (p >= n) { inverse_elements[i].push(new_element); }\n\t    }\n\t    M.elements[i] = els;\n\t    // Then, subtract this row from those above it to\n\t    // give the identity matrix on the left hand side\n\t    j = i;\n\t    while (j--) {\n\t\tels = [];\n\t\tfor (p = 0; p < np; p++) {\n\t\t    els.push(M.elements[j][p] - M.elements[i][p] * M.elements[j][i]);\n\t\t}\n\t\tM.elements[j] = els;\n\t    }\n\t}\n\treturn Matrix.create(inverse_elements);\n    },\n\n    inv: function() { return this.inverse(); },\n\n    // Returns the result of rounding all the elements\n    round: function() {\n\treturn this.map(function(x) { return Math.round(x); });\n    },\n\n    // Returns a copy of the matrix with elements set to the given value if they\n    // differ from it by less than Sylvester.precision\n    snapTo: function(x) {\n\treturn this.map(function(p) {\n\t    return (Math.abs(p - x) <= Sylvester.precision) ? x : p;\n\t});\n    },\n\n    // Returns a string representation of the matrix\n    inspect: function() {\n\tvar matrix_rows = [];\n\tvar n = this.elements.length;\n\tfor (var i = 0; i < n; i++) {\n\t    matrix_rows.push($V(this.elements[i]).inspect());\n\t}\n\treturn matrix_rows.join('\\n');\n    },\n\n    // Returns a array representation of the matrix\n    toArray: function() {\n    \tvar matrix_rows = [];\n    \tvar n = this.elements.length;\n    \tfor (var i = 0; i < n; i++) {\n        matrix_rows.push(this.elements[i]);\n    \t}\n      return matrix_rows;\n    },\n\n\n    // Set the matrix's elements from an array. If the argument passed\n    // is a vector, the resulting matrix will be a single column.\n    setElements: function(els) {\n\tvar i, j, elements = els.elements || els;\n\tif (typeof(elements[0][0]) != 'undefined') {\n\t    i = elements.length;\n\t    this.elements = [];\n\t    while (i--) {\n\t\tj = elements[i].length;\n\t\tthis.elements[i] = [];\n\t\twhile (j--) {\n\t\t    this.elements[i][j] = elements[i][j];\n\t\t}\n\t    }\n\t    return this;\n\t}\n\tvar n = elements.length;\n\tthis.elements = [];\n\tfor (i = 0; i < n; i++) {\n\t    this.elements.push([elements[i]]);\n\t}\n\treturn this;\n    },\n\n    // return the indexes of the columns with the largest value\n    // for each row\n    maxColumnIndexes: function() {\n\tvar maxes = [];\n\n\tfor(var i = 1; i <= this.rows(); i++) {\n\t    var max = null;\n\t    var maxIndex = -1;\n\n\t    for(var j = 1; j <= this.cols(); j++) {\n\t\tif(max === null || this.e(i, j) > max) {\n\t\t    max = this.e(i, j);\n\t\t    maxIndex = j;\n\t\t}\n\t    }\n\n\t    maxes.push(maxIndex);\n\t}\n\n\treturn $V(maxes);\n    },\n\n    // return the largest values in each row\n    maxColumns: function() {\n\tvar maxes = [];\n\n\tfor(var i = 1; i <= this.rows(); i++) {\n\t    var max = null;\n\n\t    for(var j = 1; j <= this.cols(); j++) {\n\t\tif(max === null || this.e(i, j) > max) {\n\t\t    max = this.e(i, j);\n\t\t}\n\t    }\n\n\t    maxes.push(max);\n\t}\n\n\treturn $V(maxes);\n    },\n\n    // return the indexes of the columns with the smallest values\n    // for each row\n    minColumnIndexes: function() {\n\tvar mins = [];\n\n\tfor(var i = 1; i <= this.rows(); i++) {\n\t    var min = null;\n\t    var minIndex = -1;\n\n\t    for(var j = 1; j <= this.cols(); j++) {\n\t\tif(min === null || this.e(i, j) < min) {\n\t\t    min = this.e(i, j);\n\t\t    minIndex = j;\n\t\t}\n\t    }\n\n\t    mins.push(minIndex);\n\t}\n\n\treturn $V(mins);\n    },\n\n    // return the smallest values in each row\n    minColumns: function() {\n\tvar mins = [];\n\n\tfor(var i = 1; i <= this.rows(); i++) {\n\t    var min = null;\n\n\t    for(var j = 1; j <= this.cols(); j++) {\n\t\tif(min === null || this.e(i, j) < min) {\n\t\t    min = this.e(i, j);\n\t\t}\n\t    }\n\n\t    mins.push(min);\n\t}\n\n\treturn $V(mins);\n    },\n    \n    // perorm a partial pivot on the matrix. essentially move the largest\n    // row below-or-including the pivot and replace the pivot's row with it.\n    // a pivot matrix is returned so multiplication can perform the transform.\n    partialPivot: function(k, j, P, A, L) {\n\tvar maxIndex = 0;\n\tvar maxValue = 0;\n\n\tfor(var i = k; i <= A.rows(); i++) {\n\t    if(Math.abs(A.e(i, j)) > maxValue) {\n\t\tmaxValue = Math.abs(A.e(k, j));\n\t\tmaxIndex = i;\n\t    }\n\t}\n\n\tif(maxIndex != k) {\n\t    var tmp = A.elements[k - 1];\n\t    A.elements[k - 1] = A.elements[maxIndex - 1];\n\t    A.elements[maxIndex - 1] = tmp;\n\t    \n\t    P.elements[k - 1][k - 1] = 0;\n\t    P.elements[k - 1][maxIndex - 1] = 1;\n\t    P.elements[maxIndex - 1][maxIndex - 1] = 0;\n\t    P.elements[maxIndex - 1][k - 1] = 1;\n\t}\n\t\n\treturn P;\n    },\n\n    // solve lower-triangular matrix * x = b via forward substitution\n    forwardSubstitute: function(b) {\n\tvar xa = [];\n\n\tfor(var i = 1; i <= this.rows(); i++) {\n\t    var w = 0;\n\n\t    for(var j = 1; j < i; j++) {\n\t\tw += this.e(i, j) * xa[j - 1];\n\t    }\n\n\t    xa.push((b.e(i) - w) / this.e(i, i));\n\t}\n\n\treturn $V(xa);\n    },\n\n    // solve an upper-triangular matrix * x = b via back substitution\n    backSubstitute: function(b) {\n\tvar xa = [];\n\n\tfor(var i = this.rows(); i > 0; i--) {\n\t    var w = 0;\n\n\t    for(var j = this.cols(); j > i; j--) {\n\t\tw += this.e(i, j) * xa[this.rows() - j];\n\t    }\n\n\t    xa.push((b.e(i) - w) / this.e(i, i));\n\t}\n\n\treturn $V(xa.reverse());\n    },\n    \n    luPack: luPack,\n    luJs: luJs,\n    svdJs: svdJs,\n    svdPack: svdPack,\n    qrJs: qrJs,\n    qrPack: qrPack\n};\n\n// LU factorization from LAPACK\nfunction luPack() {\n    var lu = lapack.lu(this.elements);\n    return {\n\tL: $M(lu.L),\n\tU: $M(lu.U),\n\tP: $M(lu.P)\n\t// don't pass back IPIV\n    };\n}\n\nvar tolerance =  1.4901e-08;\n\n// pure Javascript LU factorization\nfunction luJs() {\n    var A = this.dup();\n    var L = Matrix.I(A.rows());\n    var P = Matrix.I(A.rows());\n    var U = Matrix.Zeros(A.rows(), A.cols());\n    var p = 1;\n\n    for(var k = 1; k <= Math.min(A.cols(), A.rows()); k++) {\n\tP = A.partialPivot(k, p, P, A, L);\n\t\n\tfor(var i = k + 1; i <= A.rows(); i++) {\n\t    var l = A.e(i, p) / A.e(k, p);\n\t    L.elements[i - 1][k - 1] = l;\n\t    \n\t    for(var j = k + 1 ; j <= A.cols(); j++) {\n\t\tA.elements[i - 1][j - 1] -= A.e(k, j) * l;\n\t    }\n\t}\n\t\n\tfor(var j = k; j <= A.cols(); j++) {\n\t    U.elements[k - 1][j - 1] = A.e(k, j);\n\t}\n\n\tif(p < A.cols())\n\t    p++;\n    }    \n    \n    return {L: L, U: U, P: P};\n}\n\nfunction getLapack() {\n    try {\n\treturn require('lapack');\n    } catch(e) {}\n}\n\nvar lapack;\n\n// if node-lapack is installed use the fast, native fortran routines\nif(lapack = getLapack()) {\n    Matrix.prototype.svd = svdPack;\n    Matrix.prototype.qr = qrPack;\n    Matrix.prototype.lu = luPack;\n} else {\n    // otherwise use the slower pure Javascript versions\n    Matrix.prototype.svd = svdJs;\n    Matrix.prototype.qr = qrJs;\n    Matrix.prototype.lu = luJs;\n}\n\n// Constructor function\nMatrix.create = function(aElements, ignoreLapack) {\n    var M = new Matrix().setElements(aElements);\n    return M;\n};\n\n// Identity matrix of size n\nMatrix.I = function(n) {\n    var els = [], i = n, j;\n    while (i--) {\n\tj = n;\n\tels[i] = [];\n\twhile (j--) {\n\t    els[i][j] = (i == j) ? 1 : 0;\n\t}\n    }\n    return Matrix.create(els);\n};\n\nMatrix.loadFile = function(file) {\n    var contents = fs.readFileSync(file, 'utf-8');\n    var matrix = [];\n\n    var rowArray = contents.split('\\n');\n    for (var i = 0; i < rowArray.length; i++) {\n\tvar d = rowArray[i].split(',');\n\tif (d.length > 1) {\n\t    matrix.push(d);\n\t}\n    }\n\n    var M = new Matrix();\n    return M.setElements(matrix);\n};\n\n// Diagonal matrix - all off-diagonal elements are zero\nMatrix.Diagonal = function(elements) {\n    var i = elements.length;\n    var M = Matrix.I(i);\n    while (i--) {\n\tM.elements[i][i] = elements[i];\n    }\n    return M;\n};\n\n// Rotation matrix about some axis. If no axis is\n// supplied, assume we're after a 2D transform\nMatrix.Rotation = function(theta, a) {\n    if (!a) {\n\treturn Matrix.create([\n\t    [Math.cos(theta), -Math.sin(theta)],\n\t    [Math.sin(theta), Math.cos(theta)]\n\t]);\n    }\n    var axis = a.dup();\n    if (axis.elements.length != 3) { return null; }\n    var mod = axis.modulus();\n    var x = axis.elements[0] / mod, y = axis.elements[1] / mod, z = axis.elements[2] / mod;\n    var s = Math.sin(theta), c = Math.cos(theta), t = 1 - c;\n    // Formula derived here: http://www.gamedev.net/reference/articles/article1199.asp\n    // That proof rotates the co-ordinate system so theta\n    // becomes -theta and sin becomes -sin here.\n    return Matrix.create([\n\t[t * x * x + c, t * x * y - s * z, t * x * z + s * y],\n\t[t * x * y + s * z, t * y * y + c, t * y * z - s * x],\n\t[t * x * z - s * y, t * y * z + s * x, t * z * z + c]\n    ]);\n};\n\n// Special case rotations\nMatrix.RotationX = function(t) {\n    var c = Math.cos(t), s = Math.sin(t);\n    return Matrix.create([\n\t[1, 0, 0],\n\t[0, c, -s],\n\t[0, s, c]\n    ]);\n};\n\nMatrix.RotationY = function(t) {\n    var c = Math.cos(t), s = Math.sin(t);\n    return Matrix.create([\n\t[c, 0, s],\n\t[0, 1, 0],\n\t[-s, 0, c]\n    ]);\n};\n\nMatrix.RotationZ = function(t) {\n    var c = Math.cos(t), s = Math.sin(t);\n    return Matrix.create([\n\t[c, -s, 0],\n\t[s, c, 0],\n\t[0, 0, 1]\n    ]);\n};\n\n// Random matrix of n rows, m columns\nMatrix.Random = function(n, m) {\n    if (arguments.length === 1) m = n;\n    return Matrix.Zero(n, m).map(\n\tfunction() { return Math.random(); }\n  );\n};\n\nMatrix.Fill = function(n, m, v) {\n    if (arguments.length === 2) {\n\tv = m;\n\tm = n;\n    }\n\n    var els = [], i = n, j;\n\n    while (i--) {\n\tj = m;\n\tels[i] = [];\n\n\twhile (j--) {\n\t    els[i][j] = v;\n\t}\n    }\n\n    return Matrix.create(els);\n};\n\n// Matrix filled with zeros\nMatrix.Zero = function(n, m) {\n    return Matrix.Fill(n, m, 0);\n};\n\n// Matrix filled with zeros\nMatrix.Zeros = function(n, m) {\n    return Matrix.Zero(n, m);\n};\n\n// Matrix filled with ones\nMatrix.One = function(n, m) {\n    return Matrix.Fill(n, m, 1);\n};\n\n// Matrix filled with ones\nMatrix.Ones = function(n, m) {\n    return Matrix.One(n, m);\n};\n\nmodule.exports = Matrix;\n","/home/travis/build/npmtest/node-npmtest-sylvester/node_modules/sylvester/lib/node-sylvester/line.js":"// Copyright (c) 2011, Chris Umbel, James Coglan\nvar Vector = require('./vector');\nvar Matrix = require('./matrix');\nvar Plane = require('./plane');\nvar Sylvester = require('./sylvester');\n\n// Line class - depends on Vector, and some methods require Matrix and Plane.\n\nfunction Line() {}\nLine.prototype = {\n\n  // Returns true if the argument occupies the same space as the line\n  eql: function(line) {\n    return (this.isParallelTo(line) && this.contains(line.anchor));\n  },\n\n  // Returns a copy of the line\n  dup: function() {\n    return Line.create(this.anchor, this.direction);\n  },\n\n  // Returns the result of translating the line by the given vector/array\n  translate: function(vector) {\n    var V = vector.elements || vector;\n    return Line.create([\n      this.anchor.elements[0] + V[0],\n      this.anchor.elements[1] + V[1],\n      this.anchor.elements[2] + (V[2] || 0)\n    ], this.direction);\n  },\n\n  // Returns true if the line is parallel to the argument. Here, 'parallel to'\n  // means that the argument's direction is either parallel or antiparallel to\n  // the line's own direction. A line is parallel to a plane if the two do not\n  // have a unique intersection.\n  isParallelTo: function(obj) {\n    if (obj.normal || (obj.start && obj.end)) { return obj.isParallelTo(this); }\n    var theta = this.direction.angleFrom(obj.direction);\n    return (Math.abs(theta) <= Sylvester.precision || Math.abs(theta - Math.PI) <= Sylvester.precision);\n  },\n\n  // Returns the line's perpendicular distance from the argument,\n  // which can be a point, a line or a plane\n  distanceFrom: function(obj) {\n    if (obj.normal || (obj.start && obj.end)) { return obj.distanceFrom(this); }\n    if (obj.direction) {\n      // obj is a line\n      if (this.isParallelTo(obj)) { return this.distanceFrom(obj.anchor); }\n      var N = this.direction.cross(obj.direction).toUnitVector().elements;\n      var A = this.anchor.elements, B = obj.anchor.elements;\n      return Math.abs((A[0] - B[0]) * N[0] + (A[1] - B[1]) * N[1] + (A[2] - B[2]) * N[2]);\n    } else {\n      // obj is a point\n      var P = obj.elements || obj;\n      var A = this.anchor.elements, D = this.direction.elements;\n      var PA1 = P[0] - A[0], PA2 = P[1] - A[1], PA3 = (P[2] || 0) - A[2];\n      var modPA = Math.sqrt(PA1*PA1 + PA2*PA2 + PA3*PA3);\n      if (modPA === 0) return 0;\n      // Assumes direction vector is normalized\n      var cosTheta = (PA1 * D[0] + PA2 * D[1] + PA3 * D[2]) / modPA;\n      var sin2 = 1 - cosTheta*cosTheta;\n      return Math.abs(modPA * Math.sqrt(sin2 < 0 ? 0 : sin2));\n    }\n  },\n\n  // Returns true iff the argument is a point on the line, or if the argument\n  // is a line segment lying within the receiver\n  contains: function(obj) {\n    if (obj.start && obj.end) { return this.contains(obj.start) && this.contains(obj.end); }\n    var dist = this.distanceFrom(obj);\n    return (dist !== null && dist <= Sylvester.precision);\n  },\n\n  // Returns the distance from the anchor of the given point. Negative values are\n  // returned for points that are in the opposite direction to the line's direction from\n  // the line's anchor point.\n  positionOf: function(point) {\n    if (!this.contains(point)) { return null; }\n    var P = point.elements || point;\n    var A = this.anchor.elements, D = this.direction.elements;\n    return (P[0] - A[0]) * D[0] + (P[1] - A[1]) * D[1] + ((P[2] || 0) - A[2]) * D[2];\n  },\n\n  // Returns true iff the line lies in the given plane\n  liesIn: function(plane) {\n    return plane.contains(this);\n  },\n\n  // Returns true iff the line has a unique point of intersection with the argument\n  intersects: function(obj) {\n    if (obj.normal) { return obj.intersects(this); }\n    return (!this.isParallelTo(obj) && this.distanceFrom(obj) <= Sylvester.precision);\n  },\n\n  // Returns the unique intersection point with the argument, if one exists\n  intersectionWith: function(obj) {\n    if (obj.normal || (obj.start && obj.end)) { return obj.intersectionWith(this); }\n    if (!this.intersects(obj)) { return null; }\n    var P = this.anchor.elements, X = this.direction.elements,\n        Q = obj.anchor.elements, Y = obj.direction.elements;\n    var X1 = X[0], X2 = X[1], X3 = X[2], Y1 = Y[0], Y2 = Y[1], Y3 = Y[2];\n    var PsubQ1 = P[0] - Q[0], PsubQ2 = P[1] - Q[1], PsubQ3 = P[2] - Q[2];\n    var XdotQsubP = - X1*PsubQ1 - X2*PsubQ2 - X3*PsubQ3;\n    var YdotPsubQ = Y1*PsubQ1 + Y2*PsubQ2 + Y3*PsubQ3;\n    var XdotX = X1*X1 + X2*X2 + X3*X3;\n    var YdotY = Y1*Y1 + Y2*Y2 + Y3*Y3;\n    var XdotY = X1*Y1 + X2*Y2 + X3*Y3;\n    var k = (XdotQsubP * YdotY / XdotX + XdotY * YdotPsubQ) / (YdotY - XdotY * XdotY);\n    return Vector.create([P[0] + k*X1, P[1] + k*X2, P[2] + k*X3]);\n  },\n\n  // Returns the point on the line that is closest to the given point or line/line segment\n  pointClosestTo: function(obj) {\n    if (obj.start && obj.end) {\n      // obj is a line segment\n      var P = obj.pointClosestTo(this);\n      return (P === null) ? null : this.pointClosestTo(P);\n    } else if (obj.direction) {\n      // obj is a line\n      if (this.intersects(obj)) { return this.intersectionWith(obj); }\n      if (this.isParallelTo(obj)) { return null; }\n      var D = this.direction.elements, E = obj.direction.elements;\n      var D1 = D[0], D2 = D[1], D3 = D[2], E1 = E[0], E2 = E[1], E3 = E[2];\n      // Create plane containing obj and the shared normal and intersect this with it\n      // Thank you: http://www.cgafaq.info/wiki/Line-line_distance\n      var x = (D3 * E1 - D1 * E3), y = (D1 * E2 - D2 * E1), z = (D2 * E3 - D3 * E2);\n      var N = [x * E3 - y * E2, y * E1 - z * E3, z * E2 - x * E1];\n      var P = Plane.create(obj.anchor, N);\n      return P.intersectionWith(this);\n    } else {\n      // obj is a point\n      var P = obj.elements || obj;\n      if (this.contains(P)) { return Vector.create(P); }\n      var A = this.anchor.elements, D = this.direction.elements;\n      var D1 = D[0], D2 = D[1], D3 = D[2], A1 = A[0], A2 = A[1], A3 = A[2];\n      var x = D1 * (P[1]-A2) - D2 * (P[0]-A1), y = D2 * ((P[2] || 0) - A3) - D3 * (P[1]-A2),\n          z = D3 * (P[0]-A1) - D1 * ((P[2] || 0) - A3);\n      var V = Vector.create([D2 * x - D3 * z, D3 * y - D1 * x, D1 * z - D2 * y]);\n      var k = this.distanceFrom(P) / V.modulus();\n      return Vector.create([\n        P[0] + V.elements[0] * k,\n        P[1] + V.elements[1] * k,\n        (P[2] || 0) + V.elements[2] * k\n      ]);\n    }\n  },\n\n  // Returns a copy of the line rotated by t radians about the given line. Works by\n  // finding the argument's closest point to this line's anchor point (call this C) and\n  // rotating the anchor about C. Also rotates the line's direction about the argument's.\n  // Be careful with this - the rotation axis' direction affects the outcome!\n  rotate: function(t, line) {\n    // If we're working in 2D\n    if (typeof(line.direction) == 'undefined') { line = Line.create(line.to3D(), Vector.k); }\n    var R = Matrix.Rotation(t, line.direction).elements;\n    var C = line.pointClosestTo(this.anchor).elements;\n    var A = this.anchor.elements, D = this.direction.elements;\n    var C1 = C[0], C2 = C[1], C3 = C[2], A1 = A[0], A2 = A[1], A3 = A[2];\n    var x = A1 - C1, y = A2 - C2, z = A3 - C3;\n    return Line.create([\n      C1 + R[0][0] * x + R[0][1] * y + R[0][2] * z,\n      C2 + R[1][0] * x + R[1][1] * y + R[1][2] * z,\n      C3 + R[2][0] * x + R[2][1] * y + R[2][2] * z\n    ], [\n      R[0][0] * D[0] + R[0][1] * D[1] + R[0][2] * D[2],\n      R[1][0] * D[0] + R[1][1] * D[1] + R[1][2] * D[2],\n      R[2][0] * D[0] + R[2][1] * D[1] + R[2][2] * D[2]\n    ]);\n  },\n\n  // Returns a copy of the line with its direction vector reversed.\n  // Useful when using lines for rotations.\n  reverse: function() {\n    return Line.create(this.anchor, this.direction.x(-1));\n  },\n\n  // Returns the line's reflection in the given point or line\n  reflectionIn: function(obj) {\n    if (obj.normal) {\n      // obj is a plane\n      var A = this.anchor.elements, D = this.direction.elements;\n      var A1 = A[0], A2 = A[1], A3 = A[2], D1 = D[0], D2 = D[1], D3 = D[2];\n      var newA = this.anchor.reflectionIn(obj).elements;\n      // Add the line's direction vector to its anchor, then mirror that in the plane\n      var AD1 = A1 + D1, AD2 = A2 + D2, AD3 = A3 + D3;\n      var Q = obj.pointClosestTo([AD1, AD2, AD3]).elements;\n      var newD = [Q[0] + (Q[0] - AD1) - newA[0], Q[1] + (Q[1] - AD2) - newA[1], Q[2] + (Q[2] - AD3) - newA[2]];\n      return Line.create(newA, newD);\n    } else if (obj.direction) {\n      // obj is a line - reflection obtained by rotating PI radians about obj\n      return this.rotate(Math.PI, obj);\n    } else {\n      // obj is a point - just reflect the line's anchor in it\n      var P = obj.elements || obj;\n      return Line.create(this.anchor.reflectionIn([P[0], P[1], (P[2] || 0)]), this.direction);\n    }\n  },\n\n  // Set the line's anchor point and direction.\n  setVectors: function(anchor, direction) {\n    // Need to do this so that line's properties are not\n    // references to the arguments passed in\n    anchor = Vector.create(anchor);\n    direction = Vector.create(direction);\n    if (anchor.elements.length == 2) {anchor.elements.push(0); }\n    if (direction.elements.length == 2) { direction.elements.push(0); }\n    if (anchor.elements.length > 3 || direction.elements.length > 3) { return null; }\n    var mod = direction.modulus();\n    if (mod === 0) { return null; }\n    this.anchor = anchor;\n    this.direction = Vector.create([\n      direction.elements[0] / mod,\n      direction.elements[1] / mod,\n      direction.elements[2] / mod\n    ]);\n    return this;\n  }\n};\n\n// Constructor function\nLine.create = function(anchor, direction) {\n  var L = new Line();\n  return L.setVectors(anchor, direction);\n};\n\n// Axes\nLine.X = Line.create(Vector.Zero(3), Vector.i);\nLine.Y = Line.create(Vector.Zero(3), Vector.j);\nLine.Z = Line.create(Vector.Zero(3), Vector.k);\n\nmodule.exports = Line;\n","/home/travis/build/npmtest/node-npmtest-sylvester/node_modules/sylvester/lib/node-sylvester/plane.js":"// Copyright (c) 2011, Chris Umbel, James Coglan\n// Plane class - depends on Vector. Some methods require Matrix and Line.\nvar Vector = require('./vector');\nvar Matrix = require('./matrix');\nvar Line = require('./line');\n\nvar Sylvester = require('./sylvester');\n\nfunction Plane() {}\nPlane.prototype = {\n\n  // Returns true iff the plane occupies the same space as the argument\n  eql: function(plane) {\n    return (this.contains(plane.anchor) && this.isParallelTo(plane));\n  },\n\n  // Returns a copy of the plane\n  dup: function() {\n    return Plane.create(this.anchor, this.normal);\n  },\n\n  // Returns the result of translating the plane by the given vector\n  translate: function(vector) {\n    var V = vector.elements || vector;\n    return Plane.create([\n      this.anchor.elements[0] + V[0],\n      this.anchor.elements[1] + V[1],\n      this.anchor.elements[2] + (V[2] || 0)\n    ], this.normal);\n  },\n\n  // Returns true iff the plane is parallel to the argument. Will return true\n  // if the planes are equal, or if you give a line and it lies in the plane.\n  isParallelTo: function(obj) {\n    var theta;\n    if (obj.normal) {\n      // obj is a plane\n      theta = this.normal.angleFrom(obj.normal);\n      return (Math.abs(theta) <= Sylvester.precision || Math.abs(Math.PI - theta) <= Sylvester.precision);\n    } else if (obj.direction) {\n      // obj is a line\n      return this.normal.isPerpendicularTo(obj.direction);\n    }\n    return null;\n  },\n\n  // Returns true iff the receiver is perpendicular to the argument\n  isPerpendicularTo: function(plane) {\n    var theta = this.normal.angleFrom(plane.normal);\n    return (Math.abs(Math.PI/2 - theta) <= Sylvester.precision);\n  },\n\n  // Returns the plane's distance from the given object (point, line or plane)\n  distanceFrom: function(obj) {\n    if (this.intersects(obj) || this.contains(obj)) { return 0; }\n    if (obj.anchor) {\n      // obj is a plane or line\n      var A = this.anchor.elements, B = obj.anchor.elements, N = this.normal.elements;\n      return Math.abs((A[0] - B[0]) * N[0] + (A[1] - B[1]) * N[1] + (A[2] - B[2]) * N[2]);\n    } else {\n      // obj is a point\n      var P = obj.elements || obj;\n      var A = this.anchor.elements, N = this.normal.elements;\n      return Math.abs((A[0] - P[0]) * N[0] + (A[1] - P[1]) * N[1] + (A[2] - (P[2] || 0)) * N[2]);\n    }\n  },\n\n  // Returns true iff the plane contains the given point or line\n  contains: function(obj) {\n    if (obj.normal) { return null; }\n    if (obj.direction) {\n      return (this.contains(obj.anchor) && this.contains(obj.anchor.add(obj.direction)));\n    } else {\n      var P = obj.elements || obj;\n      var A = this.anchor.elements, N = this.normal.elements;\n      var diff = Math.abs(N[0]*(A[0] - P[0]) + N[1]*(A[1] - P[1]) + N[2]*(A[2] - (P[2] || 0)));\n      return (diff <= Sylvester.precision);\n    }\n  },\n\n  // Returns true iff the plane has a unique point/line of intersection with the argument\n  intersects: function(obj) {\n    if (typeof(obj.direction) == 'undefined' && typeof(obj.normal) == 'undefined') { return null; }\n    return !this.isParallelTo(obj);\n  },\n\n  // Returns the unique intersection with the argument, if one exists. The result\n  // will be a vector if a line is supplied, and a line if a plane is supplied.\n  intersectionWith: function(obj) {\n    if (!this.intersects(obj)) { return null; }\n    if (obj.direction) {\n      // obj is a line\n      var A = obj.anchor.elements, D = obj.direction.elements,\n          P = this.anchor.elements, N = this.normal.elements;\n      var multiplier = (N[0]*(P[0]-A[0]) + N[1]*(P[1]-A[1]) + N[2]*(P[2]-A[2])) / (N[0]*D[0] + N[1]*D[1] + N[2]*D[2]);\n      return Vector.create([A[0] + D[0]*multiplier, A[1] + D[1]*multiplier, A[2] + D[2]*multiplier]);\n    } else if (obj.normal) {\n      // obj is a plane\n      var direction = this.normal.cross(obj.normal).toUnitVector();\n      // To find an anchor point, we find one co-ordinate that has a value\n      // of zero somewhere on the intersection, and remember which one we picked\n      var N = this.normal.elements, A = this.anchor.elements,\n          O = obj.normal.elements, B = obj.anchor.elements;\n      var solver = Matrix.Zero(2,2), i = 0;\n      while (solver.isSingular()) {\n        i++;\n        solver = Matrix.create([\n          [ N[i%3], N[(i+1)%3] ],\n          [ O[i%3], O[(i+1)%3]  ]\n        ]);\n      }\n      // Then we solve the simultaneous equations in the remaining dimensions\n      var inverse = solver.inverse().elements;\n      var x = N[0]*A[0] + N[1]*A[1] + N[2]*A[2];\n      var y = O[0]*B[0] + O[1]*B[1] + O[2]*B[2];\n      var intersection = [\n        inverse[0][0] * x + inverse[0][1] * y,\n        inverse[1][0] * x + inverse[1][1] * y\n      ];\n      var anchor = [];\n      for (var j = 1; j <= 3; j++) {\n        // This formula picks the right element from intersection by\n        // cycling depending on which element we set to zero above\n        anchor.push((i == j) ? 0 : intersection[(j + (5 - i)%3)%3]);\n      }\n      return Line.create(anchor, direction);\n    }\n  },\n\n  // Returns the point in the plane closest to the given point\n  pointClosestTo: function(point) {\n    var P = point.elements || point;\n    var A = this.anchor.elements, N = this.normal.elements;\n    var dot = (A[0] - P[0]) * N[0] + (A[1] - P[1]) * N[1] + (A[2] - (P[2] || 0)) * N[2];\n    return Vector.create([P[0] + N[0] * dot, P[1] + N[1] * dot, (P[2] || 0) + N[2] * dot]);\n  },\n\n  // Returns a copy of the plane, rotated by t radians about the given line\n  // See notes on Line#rotate.\n  rotate: function(t, line) {\n    var R = t.determinant ? t.elements : Matrix.Rotation(t, line.direction).elements;\n    var C = line.pointClosestTo(this.anchor).elements;\n    var A = this.anchor.elements, N = this.normal.elements;\n    var C1 = C[0], C2 = C[1], C3 = C[2], A1 = A[0], A2 = A[1], A3 = A[2];\n    var x = A1 - C1, y = A2 - C2, z = A3 - C3;\n    return Plane.create([\n      C1 + R[0][0] * x + R[0][1] * y + R[0][2] * z,\n      C2 + R[1][0] * x + R[1][1] * y + R[1][2] * z,\n      C3 + R[2][0] * x + R[2][1] * y + R[2][2] * z\n    ], [\n      R[0][0] * N[0] + R[0][1] * N[1] + R[0][2] * N[2],\n      R[1][0] * N[0] + R[1][1] * N[1] + R[1][2] * N[2],\n      R[2][0] * N[0] + R[2][1] * N[1] + R[2][2] * N[2]\n    ]);\n  },\n\n  // Returns the reflection of the plane in the given point, line or plane.\n  reflectionIn: function(obj) {\n    if (obj.normal) {\n      // obj is a plane\n      var A = this.anchor.elements, N = this.normal.elements;\n      var A1 = A[0], A2 = A[1], A3 = A[2], N1 = N[0], N2 = N[1], N3 = N[2];\n      var newA = this.anchor.reflectionIn(obj).elements;\n      // Add the plane's normal to its anchor, then mirror that in the other plane\n      var AN1 = A1 + N1, AN2 = A2 + N2, AN3 = A3 + N3;\n      var Q = obj.pointClosestTo([AN1, AN2, AN3]).elements;\n      var newN = [Q[0] + (Q[0] - AN1) - newA[0], Q[1] + (Q[1] - AN2) - newA[1], Q[2] + (Q[2] - AN3) - newA[2]];\n      return Plane.create(newA, newN);\n    } else if (obj.direction) {\n      // obj is a line\n      return this.rotate(Math.PI, obj);\n    } else {\n      // obj is a point\n      var P = obj.elements || obj;\n      return Plane.create(this.anchor.reflectionIn([P[0], P[1], (P[2] || 0)]), this.normal);\n    }\n  },\n\n  // Sets the anchor point and normal to the plane. If three arguments are specified,\n  // the normal is calculated by assuming the three points should lie in the same plane.\n  // If only two are sepcified, the second is taken to be the normal. Normal vector is\n  // normalised before storage.\n  setVectors: function(anchor, v1, v2) {\n    anchor = Vector.create(anchor);\n    anchor = anchor.to3D(); if (anchor === null) { return null; }\n    v1 = Vector.create(v1);\n    v1 = v1.to3D(); if (v1 === null) { return null; }\n    if (typeof(v2) == 'undefined') {\n      v2 = null;\n    } else {\n      v2 = Vector.create(v2);\n      v2 = v2.to3D(); if (v2 === null) { return null; }\n    }\n    var A1 = anchor.elements[0], A2 = anchor.elements[1], A3 = anchor.elements[2];\n    var v11 = v1.elements[0], v12 = v1.elements[1], v13 = v1.elements[2];\n    var normal, mod;\n    if (v2 !== null) {\n      var v21 = v2.elements[0], v22 = v2.elements[1], v23 = v2.elements[2];\n      normal = Vector.create([\n        (v12 - A2) * (v23 - A3) - (v13 - A3) * (v22 - A2),\n        (v13 - A3) * (v21 - A1) - (v11 - A1) * (v23 - A3),\n        (v11 - A1) * (v22 - A2) - (v12 - A2) * (v21 - A1)\n      ]);\n      mod = normal.modulus();\n      if (mod === 0) { return null; }\n      normal = Vector.create([normal.elements[0] / mod, normal.elements[1] / mod, normal.elements[2] / mod]);\n    } else {\n      mod = Math.sqrt(v11*v11 + v12*v12 + v13*v13);\n      if (mod === 0) { return null; }\n      normal = Vector.create([v1.elements[0] / mod, v1.elements[1] / mod, v1.elements[2] / mod]);\n    }\n    this.anchor = anchor;\n    this.normal = normal;\n    return this;\n  }\n};\n\n// Constructor function\nPlane.create = function(anchor, v1, v2) {\n  var P = new Plane();\n  return P.setVectors(anchor, v1, v2);\n};\n\n// X-Y-Z planes\nPlane.XY = Plane.create(Vector.Zero(3), Vector.k);\nPlane.YZ = Plane.create(Vector.Zero(3), Vector.i);\nPlane.ZX = Plane.create(Vector.Zero(3), Vector.j);\nPlane.YX = Plane.XY; Plane.ZY = Plane.YZ; Plane.XZ = Plane.ZX;\n\n// Returns the plane containing the given points (can be arrays as\n// well as vectors). If the points are not coplanar, returns null.\nPlane.fromPoints = function(points) {\n  var np = points.length, list = [], i, P, n, N, A, B, C, D, theta, prevN, totalN = Vector.Zero(3);\n  for (i = 0; i < np; i++) {\n    P = Vector.create(points[i]).to3D();\n    if (P === null) { return null; }\n    list.push(P);\n    n = list.length;\n    if (n > 2) {\n      // Compute plane normal for the latest three points\n      A = list[n-1].elements; B = list[n-2].elements; C = list[n-3].elements;\n      N = Vector.create([\n        (A[1] - B[1]) * (C[2] - B[2]) - (A[2] - B[2]) * (C[1] - B[1]),\n        (A[2] - B[2]) * (C[0] - B[0]) - (A[0] - B[0]) * (C[2] - B[2]),\n        (A[0] - B[0]) * (C[1] - B[1]) - (A[1] - B[1]) * (C[0] - B[0])\n      ]).toUnitVector();\n      if (n > 3) {\n        // If the latest normal is not (anti)parallel to the previous one, we've strayed off the plane.\n        // This might be a slightly long-winded way of doing things, but we need the sum of all the normals\n        // to find which way the plane normal should point so that the points form an anticlockwise list.\n        theta = N.angleFrom(prevN);\n        if (theta !== null) {\n          if (!(Math.abs(theta) <= Sylvester.precision || Math.abs(theta - Math.PI) <= Sylvester.precision)) { return null; }\n        }\n      }\n      totalN = totalN.add(N);\n      prevN = N;\n    }\n  }\n  // We need to add in the normals at the start and end points, which the above misses out\n  A = list[1].elements; B = list[0].elements; C = list[n-1].elements; D = list[n-2].elements;\n  totalN = totalN.add(Vector.create([\n    (A[1] - B[1]) * (C[2] - B[2]) - (A[2] - B[2]) * (C[1] - B[1]),\n    (A[2] - B[2]) * (C[0] - B[0]) - (A[0] - B[0]) * (C[2] - B[2]),\n    (A[0] - B[0]) * (C[1] - B[1]) - (A[1] - B[1]) * (C[0] - B[0])\n  ]).toUnitVector()).add(Vector.create([\n    (B[1] - C[1]) * (D[2] - C[2]) - (B[2] - C[2]) * (D[1] - C[1]),\n    (B[2] - C[2]) * (D[0] - C[0]) - (B[0] - C[0]) * (D[2] - C[2]),\n    (B[0] - C[0]) * (D[1] - C[1]) - (B[1] - C[1]) * (D[0] - C[0])\n  ]).toUnitVector());\n  return Plane.create(list[0], totalN);\n};\n\nmodule.exports = Plane;\n","/home/travis/build/npmtest/node-npmtest-sylvester/node_modules/sylvester/lib/node-sylvester/line.segment.js":"// Copyright (c) 2011, Chris Umbel, James Coglan\n// Line.Segment class - depends on Line and its dependencies.\n\nvar Line = require('./line');\nvar Vector = require('./vector');\n\nLine.Segment = function() {};\nLine.Segment.prototype = {\n\n  // Returns true iff the line segment is equal to the argument\n  eql: function(segment) {\n    return (this.start.eql(segment.start) && this.end.eql(segment.end)) ||\n        (this.start.eql(segment.end) && this.end.eql(segment.start));\n  },\n\n  // Returns a copy of the line segment\n  dup: function() {\n    return Line.Segment.create(this.start, this.end);\n  },\n\n  // Returns the length of the line segment\n  length: function() {\n    var A = this.start.elements, B = this.end.elements;\n    var C1 = B[0] - A[0], C2 = B[1] - A[1], C3 = B[2] - A[2];\n    return Math.sqrt(C1*C1 + C2*C2 + C3*C3);\n  },\n\n  // Returns the line segment as a vector equal to its\n  // end point relative to its endpoint\n  toVector: function() {\n    var A = this.start.elements, B = this.end.elements;\n    return Vector.create([B[0] - A[0], B[1] - A[1], B[2] - A[2]]);\n  },\n\n  // Returns the segment's midpoint as a vector\n  midpoint: function() {\n    var A = this.start.elements, B = this.end.elements;\n    return Vector.create([(B[0] + A[0])/2, (B[1] + A[1])/2, (B[2] + A[2])/2]);\n  },\n\n  // Returns the plane that bisects the segment\n  bisectingPlane: function() {\n    return Plane.create(this.midpoint(), this.toVector());\n  },\n\n  // Returns the result of translating the line by the given vector/array\n  translate: function(vector) {\n    var V = vector.elements || vector;\n    var S = this.start.elements, E = this.end.elements;\n    return Line.Segment.create(\n      [S[0] + V[0], S[1] + V[1], S[2] + (V[2] || 0)],\n      [E[0] + V[0], E[1] + V[1], E[2] + (V[2] || 0)]\n    );\n  },\n\n  // Returns true iff the line segment is parallel to the argument. It simply forwards\n  // the method call onto its line property.\n  isParallelTo: function(obj) {\n    return this.line.isParallelTo(obj);\n  },\n\n  // Returns the distance between the argument and the line segment's closest point to the argument\n  distanceFrom: function(obj) {\n    var P = this.pointClosestTo(obj);\n    return (P === null) ? null : P.distanceFrom(obj);\n  },\n\n  // Returns true iff the given point lies on the segment\n  contains: function(obj) {\n    if (obj.start && obj.end) { return this.contains(obj.start) && this.contains(obj.end); }\n    var P = (obj.elements || obj).slice();\n    if (P.length == 2) { P.push(0); }\n    if (this.start.eql(P)) { return true; }\n    var S = this.start.elements;\n    var V = Vector.create([S[0] - P[0], S[1] - P[1], S[2] - (P[2] || 0)]);\n    var vect = this.toVector();\n    return V.isAntiparallelTo(vect) && V.modulus() <= vect.modulus();\n  },\n\n  // Returns true iff the line segment intersects the argument\n  intersects: function(obj) {\n    return (this.intersectionWith(obj) !== null);\n  },\n\n  // Returns the unique point of intersection with the argument\n  intersectionWith: function(obj) {\n    if (!this.line.intersects(obj)) { return null; }\n    var P = this.line.intersectionWith(obj);\n    return (this.contains(P) ? P : null);\n  },\n\n  // Returns the point on the line segment closest to the given object\n  pointClosestTo: function(obj) {\n    if (obj.normal) {\n      // obj is a plane\n      var V = this.line.intersectionWith(obj);\n      if (V === null) { return null; }\n      return this.pointClosestTo(V);\n    } else {\n      // obj is a line (segment) or point\n      var P = this.line.pointClosestTo(obj);\n      if (P === null) { return null; }\n      if (this.contains(P)) { return P; }\n      return (this.line.positionOf(P) < 0 ? this.start : this.end).dup();\n    }\n  },\n\n  // Set the start and end-points of the segment\n  setPoints: function(startPoint, endPoint) {\n    startPoint = Vector.create(startPoint).to3D();\n    endPoint = Vector.create(endPoint).to3D();\n    if (startPoint === null || endPoint === null) { return null; }\n    this.line = Line.create(startPoint, endPoint.subtract(startPoint));\n    this.start = startPoint;\n    this.end = endPoint;\n    return this;\n  }\n};\n\n// Constructor function\nLine.Segment.create = function(v1, v2) {\n  var S = new Line.Segment();\n  return S.setPoints(v1, v2);\n};\n\nmodule.exports = Line.Segment;\n","/home/travis/build/npmtest/node-npmtest-sylvester/node_modules/sylvester/spec/line_segment_spec.js":"\nvar sylvester = require('../lib/node-sylvester'),\nLine = sylvester.Line,\nLineSegment = sylvester.Line.Segment,\nVector = sylvester.Vector;\n\ndescribe('line segment', function() {\n    it('should create', function() {\n\tvar lineSegment = Line.Segment.create([1, 2], [5, 6]);\n\texpect(lineSegment.line.anchor).toEqual(Vector.create([1, 2, 0]));\n    })\n});\n","/home/travis/build/npmtest/node-npmtest-sylvester/node_modules/sylvester/spec/line_spec.js":"\nvar sylvester = require('../lib/node-sylvester'),\nLine = sylvester.Line,\nVector = sylvester.Vector;\n\ndescribe('line', function() {\n    it('should create', function() {\n\tvar line = Line.create([1, 2], [5, 6]);\n\texpect(line.anchor).toEqual(Vector.create([1, 2, 0]));\n    })\n\n    it('should create with $L', function() {\n\tvar a = Line.create([1, 2], [5, 6]);\n\tvar b = $L([1, 2], [5, 6]);\n\texpect(a).toEqual(b);\n    });\n});\n","/home/travis/build/npmtest/node-npmtest-sylvester/node_modules/sylvester/spec/matrix_spec.js":"\nvar sylvester = require('../lib/node-sylvester'),\nMatrix = sylvester.Matrix;\nvar A = Matrix.create([[1, 2, 3], [4, 5, 6]]);\n\ndescribe('matrix', function() {\n    it('should forward substitute', function() {\n\tvar L = $M([\n\t    [1, 0, 0],\n\t    [0.5, 1, 0],\n\t    [2, 3, 1]\n\t]);\n\n\tvar b = $V([1, 2, 3]);\n\n\texpect(L.forwardSubstitute(b).eql($V([1, 1.5, -3.5]))).toBeTruthy();\n    });\n\n    it('should back substitute', function() {\n\tvar L = $M([\n\t    [4, 4],\n\t    [0, 1],\n\t]);\n\n\tvar b = $V([1, 1.5]);\n\n\texpect(L.backSubstitute(b).eql($V([-1.25, 1.5]))).toBeTruthy();\n    });\n\n    it('should solve', function() {\n\t// 2x + 3y = 2\n\t// 4x + 4y = 1\n\n\t// x = -1.25 \n\t// y = 1.5\n\tvar M = $M([\n\t    [2, 3],\n\t    [4, 4],\n\t]);\n\n\tvar b = $V([2, 1]);\n\texpect(M.solve(b).eql($V([-1.25, 1.5])));\n    });\n\n    it('should partial pivot', function() {\n        var B = $M([\n            [3,  6,  -9],\n            [-4, 1 , 10],\n            [2,  5,  -3]\n        ]);\n\t\n\tvar P = Matrix.I(3);\n\tB.partialPivot(1, 1, P, B);\n\t\n\texpect(B.eql($M([\n            [-4,  1 ,  10],\n\t    [ 3,  6,  -9],\n\t    [ 2,  5,  -3]\n\t]))).toBeTruthy();\n\n\texpect(P.eql($M([\n\t    [0, 1, 0], \n\t    [1, 0, 0],\n\t    [0, 0, 1]\n\t]))).toBeTruthy();\n    });\n\n    describe('LU decomp', function() {\n\tit('should perform LU decomp on rectangular matrices', function() {\n\t    var D = $M([\n\t\t[3, 6],\n\t\t[2, 3],\n\t\t[4, 3],\n\t\t[2, 120],\n\t    ]);\n\n\t    var lu = D.luJs();\n\t    expect(lu.P.x((lu.L.x(lu.U))).eql(D)).toBeTruthy();\n\n\t    lu = D.luPack();\n\t    expect(lu.P.x((lu.L.x(lu.U))).eql(D)).toBeTruthy();\n\t});\n\n\tit('should perform LU decomp', function() {\n\t    var A = $M([\n\t\t[4,  2, 1,  4],\n\t\t[-9, 4, 3,  9],\n\t\t[11, 3, 11, 3],\n\t\t[-4, 5, 3,  1]\n\t    ]);\n\t    \n\t    var lu = A.lu();\n\t    \n\t    expect(lu.L.approxEql($M([\n\t\t[ 1, 0, 0, 0],\n\t\t[-0.818181818181818 , 1, 0, 0],\n\t\t[0.363636363636364, 0.140845070422535, 1, 0],\n\t\t[-0.363636363636364, 0.943661971830986, 0.921921921921922, 1]\n\t    ]))).toBeTruthy();\n\t    \n\t    expect(lu.U.approxEql($M([\n\t\t[11, 3, 11, 3],\n\t\t[ 0, 6.454545454545455, 12, 11.454545454545455],\n\t\t[ 0, 0, -4.690140845070422, 1.295774647887324],\n\t\t[ 0, 0, 0, -9.912912912912912]\n\t    ]))).toBeTruthy();\n\t    \n\t    expect(lu.P.eql($M([\n\t\t[0, 0, 1, 0],\n\t\t[0, 1, 0, 0],\n\t\t[1, 0, 0, 0],\n\t\t[0, 0, 0, 1]\n\t    ]))).toBeTruthy();\n\t});\n\t\n\t   it('should match LU JS to LAPACK', function() {\n               var A = $M([\n\t\t   [4,  2, 1,  4],\n\t\t   [-9, 4, 3,  9],\n\t\t   [11, 3, 11, 3],\n\t\t   [-4, 5, 3,  1]\n               ]);\n\t       \n\t       expect(A.luJs().U.approxEql(A.luPack().U)).toBeTruthy();\n\t       expect(A.luJs().L.approxEql(A.luPack().L)).toBeTruthy();\n\t   });\n    });\n    \n    describe('PCA', function() {\n\tit('should PCA', function() {\n\t    var pca = $M([[1, 2], [5, 7]]).pcaProject(1);\t    \n\t    \n\t    expect(pca.Z.approxEql($M([\n\t\t[-2.2120098720461616],\n\t\t[-8.601913944732665]\n            ]))).toBeTruthy();\n\n\t    expect(pca.U.approxEql($M([[-0.5732529283807336, -0.819378471832714],\n\t\t\t\t [-0.819378471832714, 0.5732529283807336]]))).toBeTruthy();\n\n\t});\t\n\n\tit('should recover', function() {\n            var U = $M([[-0.5732529283807336, -0.819378471832714],\n\t\t\t[-0.819378471832714, 0.5732529283807336]]);\n            var Z = $M([[-2.2120098720461616],\n\t\t\t[-8.601913944732665]]);\n\n            expect(Z.pcaRecover(U).eql($M([\n\t\t[1.268041136757554, 1.812473268636061],\n\t\t[4.931072358497068, 7.048223102871564]\n            ]))).toBeTruthy();\n\t});\n    });\n\n    it('shoud triu', function () {\n\tvar A2 = $M([\n\t    [ 1, -1,  2,  2],\n\t    [-1,  2,  1, -1],\n\t    [ 2,  1,  3,  2],\n\t    [ 2, -1,  2,  1]\n\t]);\n\n\texpect(A2.triu().eql($M([\n\t    [ 1, -1,  2,  2],\n\t    [ 0,  2,  1, -1],\n\t    [ 0,  0,  3,  2],\n\t    [ 0,  0,  0,  1]\n\t]))).toBeTruthy();\n\n\texpect(A2.triu(1).eql($M([\n\t    [ 0, -1,  2,  2],\n\t    [ 0,  0,  1, -1],\n\t    [ 0,  0,  0,  2],\n\t    [ 0,  0,  0,  0]\n\t]))).toBeTruthy();\n    });\n\n    it('should unroll', function() {\n\texpect(A.unroll().eql($V([1, 4, 2, 5, 3, 6]))).toBeTruthy();\n    });\n\n    it('should slice', function() {\n\tvar A2 = $M([[1,2,3], [4,5,6], [7,8,9]]);\n\tvar A3 = A2.slice(2, 3, 2, 3);\n\texpect(A3.eql($M([[5, 6], [8, 9]]))).toBeTruthy();\n    });\n\n    var U = $M([[-0.5110308651281587, 0.2132007163556105, 0.7071067811881557, 0.4397646068404634],\n                [0.08729449334404742, -0.8528028654224428, 1.882731224298497e-12, 0.514885369921382],\n                [-0.6856198518162525, -0.42640143271122105, -2.157344709257849e-12, -0.5900061329997158],\n                [-0.5110308651281581, 0.21320071635561055, -0.7071067811849397, 0.4397646068456342]]);\n    var S = $M([[5.85410196624969, 0, 0, 0],\n                [0, 2.999999999999999, 0, 0],\n                [0, 0, 1.0000000000000002, 0],\n                [0, 0, 0, 0.8541019662496846]]);\n    var V = $M([[-0.5110308651281575, 0.21320071635561047, -0.7071067811884307, -0.43976460684002194],\n                [0.08729449334404744, -0.8528028654224414, -2.2043789591597237e-12, -0.5148853699213815],\n                [-0.6856198518162527, -0.42640143271122066, 2.525858488366184e-12, 0.590006132999716],\n                [-0.5110308651281579, 0.21320071635561044, 0.7071067811846652, -0.4397646068460757],\n               ]);\n\n    var ASVD = $M([\n\t[ 1, -1, 2,  2],\n\t[-1,  2, 1, -1],\n\t[ 2,  1, 3,  2],\n\t[ 2, -1, 2,  1]\n    ]);\n    \n    it('should svd', function() {\n\tvar svd = ASVD.svdJs();\t\n\texpect(svd.U.eql(U)).toBeTruthy();\n\texpect(svd.S.eql(S)).toBeTruthy();\n\texpect(svd.V.eql(V)).toBeTruthy();\n    });\n\n    it('should have matching svds for js and lapack', function() {\n\tvar svdJs = ASVD.svdJs();\t\n\tvar svdPack = ASVD.svdPack();\n\n\texpect(svdJs.U.eql(svdPack.U)).toBeTruthy();\n\texpect(svdJs.S.eql(svdPack.S)).toBeTruthy();\n\texpect(svdJs.V.eql(svdPack.V)).toBeTruthy();\n    });\n\n    var QRin = $M([\n        [1, -1, 2, 2],\n        [-1, 2, 1, -1],\n        [2, 1, 3, 2],\n        [2, -1, 2, 1]\n    ]);\n\n    var Qout = $M([[-0.316227766016838, 0.28342171556262064, 0.8226876614429064, -0.3779644730092273],\n                   [0.31622776601683794, -0.6883098806520787, 0.5323273103454103, 0.3779644730092272],\n                   [-0.6324555320336759, -0.6478210641431328, -0.19357356739833098, -0.37796447300922714],\n                   [-0.6324555320336759, 0.16195526603578317, 0.048393391849582745, 0.7559289460184544]]);\n    var Rout = $M([[-3.1622776601683795, 0.9486832980505139, -3.478505426185217, -2.8460498941515415],\n                   [1.91055907392895e-17, -2.4698178070456938, -1.7410191098846692, 0.1214664495268375],\n                   [-2.254600901479451e-16, 2.0686390257580927e-16, 1.6937687147353957, 0.7742942695933234],\n                   [3.446764628337833e-17, 8.098938594673387e-17, 2.220446049250313e-16, -1.1338934190276815]]);\n\n    it('should qr from javascript', function() {\n\tvar qr = QRin.qrJs();\n\texpect(qr.Q.eql(Qout)).toBeTruthy();\n\texpect(qr.R.eql(Rout)).toBeTruthy();\n    });\n\n    it('should qr from lapack', function() {\n\tvar qr = QRin.qrPack();\n\texpect(qr.Q.eql(Qout)).toBeTruthy();\n\texpect(qr.R.eql(Rout)).toBeTruthy();\n    });\n\n    it('should create a 1\\'s matrix', function() {\n\tvar Ones = Matrix.One(2, 3);\n\texpect(Ones.eql($M([[1,1,1], [1,1,1]]))).toBeTruthy();\n    });\n\n    it('columns should be retrievable as vectors', function() {\n\texpect(A.column(2).eql($V([2, 5]))).toBeTruthy();\n    });\n\n    it('should log', function() {\n\texpect(A.log().eql($M([[0, 0.6931471805599453, 1.0986122886681098],\n\t\t\t       [1.3862943611198906, 1.6094379124341003, 1.791759469228055]]))).toBeTruthy();\n    });\n\n    it('should sum', function() {\n\texpect(A.sum()).toBe(21);\n    });\n\n    it('should multiply', function() {\n\texpect(A.x(Matrix.create([[1, 2], [3, 4], [5, 6]])).eql(Matrix.create([[22, 28], [49, 64]]))).toBeTruthy();\n    });\n\n    it('should multiply', function() {\n\tvar B = $M([[1, 2, 3], [4, 5, 6]]);\n\texpect(A.eql(B)).toBeTruthy();\n    });\n\n    it('should evaluate equal matrices', function() {\n\tvar A = $M([[1, 2, 3], [4, 5, 6]]);\n\tvar B = $M([[1, 2, 3], [4, 5, 6]]);\n\n\texpect(A.eql(B)).toBeTruthy();\n    });\n\n    it('should evaluate inequal matrices', function() {\n\tvar A = $M([[1, 2, 3], [4, 5, 6]]);\n\tvar B = $M([[1, 2, 3], [4, 5, 7]]);\n\n\texpect(A.eql(B)).toBeFalsy();\n    });\n\n    it('should snap', function() {\n\texpect($M([[1, 1.1, 1.00000001], [4, 5, 6]]).snapTo(1).eql(\n\t    $M([[1, 1.1, 1], [4, 5, 6]]))).toBeTruthy();\n    });\n\n    it('should compute the minimum index of matrix rows', function() {\n\texpect($M([[1, 2, 3], [2, 1, 3], [2, 1, 0]]).minColumnIndexes().eql($V([2, 1, 3])));\n    });\n\n    it('should compute the minimum value of matrix rows', function() {\n\texpect($M([[1, 2, 3], [2, 1, 3], [2, 1, 0]]).minColumns().eql($V([1, 1, 0])));\n    });\n\n    it('should compute the maximum index of matrix rows', function() {\n\texpect($M([[1, 2, 3], [2, 3, 2], [2, 1, 0]]).maxColumnIndexes().eql($V([3, 2, 1])));\n    });\n\n    it('should compute the maximum value of matrix rows', function() {\n\texpect($M([[1, 2, 3], [2, 1, 3], [2, 1, 0]]).maxColumns().eql($V([3, 3, 2])));\n    });\n});\n","/home/travis/build/npmtest/node-npmtest-sylvester/node_modules/sylvester/spec/plane_spec.js":"var sylvester = require('../lib/node-sylvester'),\nVector = sylvester.Vector,\nPlane = sylvester.Plane;\n\ndescribe('plane', function() {\n    it('should create', function() {\n\tvar plane = Plane.create([1,2,3], [5, 5, 5]);\n\texpect(plane.anchor).toEqual(Vector.create([1, 2, 3]));\n    });\n\n    it('should create with P$', function() {\n\tvar A = Plane.create([1,2,3], [5, 5, 5]);\n\tvar B = $P([1,2,3], [5, 5, 5]);\n\n\texpect(A).toEqual(B);\n    });\n});","/home/travis/build/npmtest/node-npmtest-sylvester/node_modules/sylvester/spec/vector_spec.js":"\nvar sylvester = require('../lib/node-sylvester'),\nVector = sylvester.Vector;\n\nvar x = Vector.create([1, 2, 3]);\n\ndescribe('vector', function() {\n    it('should norm', function() {\n\texpect($V([1, 2, 3]).norm()).toBe(3.7416573867739413);\n    });\n    \n    it('should log', function() {\n\texpect(x.log()).toEqual($V([0, 0.6931471805599453, 1.0986122886681098]));\n    });\n\n    it('should dot product', function() {\n\texpect(x.dot(Vector.create([2, 3, 4]))).toBe(20);\n    });\n\n    it('should support removal of head positions', function() {\n\texpect(x.chomp(1)).toEqual($V([2, 3]));\n    });\n\n    it('should sum', function() {\n\texpect(x.sum()).toBe(6);\n    });\n\n    it('should support addition of elements on the right side', function() {\n\texpect(x.augment([4, 5])).toEqual($V([1, 2, 3, 4, 5]));\n    })\n\n    it('should create with $V', function() {\n\tvar a = $V([2, 3, 4]);\n\tvar b = Vector.create([2, 3, 4]);\n\texpect(a).toEqual(b);\n    });\n\n    it('show allow for scalar addition', function() {\n\tvar a = $V([2, 3, 4]);\n\tvar b = a.add(1);\n\texpect(b.eql($V([3, 4, 5]))).toBeTruthy();\n    });\n\n    it('show add', function() {\n\tvar a = $V([2, 3, 4]);\n\tvar b = a.add($V([2, 4, 8]));\n\texpect(b.eql($V([, 7, 12]))).toBeTruthy();\n    });\n});\n","/home/travis/build/npmtest/node-npmtest-sylvester/node_modules/sylvester/lib/node-sylvester/linkedlist.js":"// Copyright (c) 2011, Chris Umbel, James Coglan\n// LinkedList class - required for Polygon class.\n\nfunction LinkedList() {}\nLinkedList.prototype = {\n  length: 0,\n  first: null,\n  last: null,\n\n  each: function(fn) {\n    var node = this.first, n = this.length;\n    for (var i = 0; i < n; i++) {\n      fn(node, i);\n      node = node.next;\n    }\n  },\n\n  at: function(i) {\n    if (!(i >= 0 && i < this.length)) { return null; }\n    var node = this.first;\n    while (i--) { node = node.next; }\n    return node;\n  },\n\n  randomNode: function() {\n    var n = Math.floor(Math.random() * this.length);\n    return this.at(n);\n  },\n\n  toArray: function() {\n    var arr = [], node = this.first, n = this.length;\n    while (n--) {\n      arr.push(node.data || node);\n      node = node.next;\n    }\n    return arr;\n  }\n};\n\nLinkedList.Node = function(data) {\n  this.prev = null; this.next = null;\n  this.data = data;\n};\n\nLinkedList.Circular = function() {};\nLinkedList.Circular.Methods = {\n  append: function(node) {\n    if (this.first === null) {\n      node.prev = node;\n      node.next = node;\n      this.first = node;\n      this.last = node;\n    } else {\n      node.prev = this.last;\n      node.next = this.first;\n      this.first.prev = node;\n      this.last.next = node;\n      this.last = node;\n    }\n    this.length++;\n  },\n\n  prepend: function(node) {\n    if (this.first === null) {\n      this.append(node);\n      return;\n    } else {\n      node.prev = this.last;\n      node.next = this.first;\n      this.first.prev = node;\n      this.last.next = node;\n      this.first = node;\n    }\n    this.length++;\n  },\n\n  insertAfter: function(node, newNode) {\n    newNode.prev = node;\n    newNode.next = node.next;\n    node.next.prev = newNode;\n    node.next = newNode;\n    if (newNode.prev == this.last) { this.last = newNode; }\n    this.length++;\n  },\n\n  insertBefore: function(node, newNode) {\n    newNode.prev = node.prev;\n    newNode.next = node;\n    node.prev.next = newNode;\n    node.prev = newNode;\n    if (newNode.next == this.first) { this.first = newNode; }\n    this.length++;\n  },\n\n  remove: function(node) {\n    if (this.length > 1) {\n      node.prev.next = node.next;\n      node.next.prev = node.prev;\n      if (node == this.first) { this.first = node.next; }\n      if (node == this.last) { this.last = node.prev; }\n    } else {\n      this.first = null;\n      this.last = null;\n    }\n    node.prev = null;\n    node.next = null;\n    this.length--;\n  },\n\n  withData: function(data) {\n    var nodeFromStart = this.first, nodeFromEnd = this.last, n = Math.ceil(this.length / 2);\n    while (n--) {\n      if (nodeFromStart.data == data) { return nodeFromStart; }\n      if (nodeFromEnd.data == data) { return nodeFromEnd; }\n      nodeFromStart = nodeFromStart.next;\n      nodeFromEnd = nodeFromEnd.prev;\n    }\n    return null;\n  }\n};\n\nLinkedList.Circular.prototype = new LinkedList;\nfor (var method in LinkedList.Circular.Methods) {\n  LinkedList.Circular.prototype[method] = LinkedList.Circular.Methods[method];\n}\n\nLinkedList.Circular.fromArray = function(list, useNodes) {\n  var linked = new LinkedList.Circular();\n  var n = list.length;\n  while (n--) { linked.prepend(useNodes ? new LinkedList.Node(list[n]) : list[n]); }\n  return linked;\n};\n\nmodule.exports = LinkedList;\n","/home/travis/build/npmtest/node-npmtest-sylvester/node_modules/sylvester/lib/node-sylvester/polygon.js":"// Copyright (c) 2011, Chris Umbel, James Coglan\n// Polygon class - depends on Vector, Plane, Polygon.Vertex and LinkedList.\n\nvar Sylvester = require('./sylvester');\n\nfunction Polygon() {}\nPolygon.prototype = {\n\n  // Returns the vertex at the given position on the vertex list, numbered from 1.\n  v: function(i) {\n    return this.vertices.at(i - 1).data;\n  },\n\n  // Returns the node in the vertices linked list that refers to the given vertex.\n  nodeFor: function(vertex) {\n    return this.vertices.withData(vertex);\n  },\n\n  // Returns a new polygon with the same vertices as the receiver. The vertices\n  // will not be duplicates, they refer to the same objects as the vertices in this\n  // polygon, but the linked list and nodes used to point to them are separate and\n  // can be manipulated independently of this one.\n  dup: function() {\n    return Polygon.create(this.vertices, this.plane);\n  },\n\n  // Translates the polygon by the given vector and returns the polygon.\n  translate: function(vector) {\n    var P = vector.elements || vector;\n    this.vertices.each(function(node) {\n      var E = node.data.elements;\n      node.data.setElements([E[0] + P[0], E[1] + P[1], E[2] + (P[2] || 0)]);\n    });\n    this.plane = this.plane.translate(vector);\n    this.updateTrianglePlanes(function(plane) { return plane.translate(vector); });\n    return this;\n  },\n\n  // Rotates the polygon about the given line and returns the polygon.\n  rotate: function(t, line) {\n    var R = Matrix.Rotation(t, line.direction);\n    this.vertices.each(function(node) {\n      node.data.setElements(node.data.rotate(R, line).elements);\n    });\n    this.plane = this.plane.rotate(R, line);\n    this.updateTrianglePlanes(function(plane) { return plane.rotate(R, line); });\n    return this;\n  },\n\n  // Scales the polygon relative to the given point and returns the polygon.\n  scale: function(k, point) {\n    var P = point.elements || point;\n    this.vertices.each(function(node) {\n      var E = node.data.elements;\n      node.data.setElements([\n        P[0] + k * (E[0] - P[0]),\n        P[1] + k * (E[1] - P[1]),\n        (P[2] || 0) + k * (E[2] - (P[2] || 0))\n      ]);\n    });\n    var anchor = this.vertices.first.data;\n    this.plane.anchor.setElements(anchor);\n    this.updateTrianglePlanes(function(plane) { return Plane.create(anchor, plane.normal); });\n    return this;\n  },\n\n  // Updates the plane properties of all the cached triangles belonging to\n  // the polygon according to the given function. For example, suppose you\n  // just rotated the polygon, you should call:\n  //\n  //   poly.updateTrianglePlanes(function(plane) { return plane.rotate(t, line); });\n  //\n  // This method is called automatically by Polygon.translate, Polygon.rotate\n  // and Polygon.scale transformation methods.\n  updateTrianglePlanes: function(fn) {\n    var i;\n    if (this.cached.triangles !== null) {\n      i = this.cached.triangles.length;\n      while (i--) {\n        this.cached.triangles[i].plane = fn(this.cached.triangles[i].plane);\n      }\n    }\n    if (this.cached.surfaceIntegralElements !== null) {\n      i = this.cached.surfaceIntegralElements.length;\n      while (i--) {\n        this.cached.surfaceIntegralElements[i].plane = fn(this.cached.surfaceIntegralElements[i].plane);\n      }\n    }\n  },\n\n  // Returns true iff the polygon is a triangle\n  isTriangle: function() {\n    return this.vertices.length == 3;\n  },\n\n  // Returns a collection of triangles used for calculating area and center of mass.\n  // Some of the triangles will not lie inside the polygon - this collection is essentially\n  // a series of itervals in a surface integral, so some are 'negative'. If you want the\n  // polygon broken into constituent triangles, use toTriangles(). This method is used\n  // because it's much faster than toTriangles().\n  // The triangles generated share vertices with the original polygon, so they transform\n  // with the polygon. They are cached after first calculation and should remain in sync\n  // with changes to the parent polygon.\n  trianglesForSurfaceIntegral: function() {\n    if (this.cached.surfaceIntegralElements !== null) { return this.cached.surfaceIntegralElements; }\n    var triangles = [];\n    var firstVertex = this.vertices.first.data;\n    var plane = this.plane;\n    this.vertices.each(function(node, i) {\n      if (i < 2) { return; }\n      var points = [firstVertex, node.prev.data, node.data];\n      // If the vertices lie on a straigh line, give the polygon's own plane. If the\n      // element has no area, it doesn't matter which way its normal faces.\n      triangles.push(Polygon.create(points, Plane.fromPoints(points) || plane));\n    });\n    return this.setCache('surfaceIntegralElements', triangles);\n  },\n\n  // Returns the area of the polygon. Requires that the polygon\n  // be converted to triangles, so use with caution.\n  area: function() {\n    if (this.isTriangle()) {\n      // Area is half the modulus of the cross product of two sides\n      var A = this.vertices.first, B = A.next, C = B.next;\n      A = A.data.elements; B = B.data.elements; C = C.data.elements;\n      return 0.5 * Vector.create([\n        (A[1] - B[1]) * (C[2] - B[2]) - (A[2] - B[2]) * (C[1] - B[1]),\n        (A[2] - B[2]) * (C[0] - B[0]) - (A[0] - B[0]) * (C[2] - B[2]),\n        (A[0] - B[0]) * (C[1] - B[1]) - (A[1] - B[1]) * (C[0] - B[0])\n      ]).modulus();\n    } else {\n      var trigs = this.trianglesForSurfaceIntegral(), area = 0;\n      var i = trigs.length;\n      while (i--) {\n        area += trigs[i].area() * trigs[i].plane.normal.dot(this.plane.normal);\n      }\n      return area;\n    }\n  },\n\n  // Returns the centroid of the polygon. Requires division into\n  // triangles - use with caution\n  centroid: function() {\n    if (this.isTriangle()) {\n      var A = this.v(1).elements, B = this.v(2).elements, C = this.v(3).elements;\n      return Vector.create([(A[0] + B[0] + C[0])/3, (A[1] + B[1] + C[1])/3, (A[2] + B[2] + C[2])/3]);\n    } else {\n      var A, M = 0, V = Vector.Zero(3), P, C, trigs = this.trianglesForSurfaceIntegral();\n      var i = trigs.length;\n      while (i--) {\n        A = trigs[i].area() * trigs[i].plane.normal.dot(this.plane.normal);\n        M += A;\n        P = V.elements;\n        C = trigs[i].centroid().elements;\n        V.setElements([P[0] + C[0] * A, P[1] + C[1] * A, P[2] + C[2] * A]);\n      }\n      return V.x(1/M);\n    }\n  },\n\n  // Returns the polygon's projection on the given plane as another polygon\n  projectionOn: function(plane) {\n    var points = [];\n    this.vertices.each(function(node) { points.push(plane.pointClosestTo(node.data)); });\n    return Polygon.create(points);\n  },\n\n  // Removes the given vertex from the polygon as long as it's not triangular.\n  removeVertex: function(vertex) {\n    if (this.isTriangle()) { return; }\n    var node = this.nodeFor(vertex);\n    if (node === null) { return null; }\n    this.clearCache();\n    // Previous and next entries in the main vertex list\n    var prev = node.prev, next = node.next;\n    var prevWasConvex = prev.data.isConvex(this);\n    var nextWasConvex = next.data.isConvex(this);\n    if (node.data.isConvex(this)) {\n      this.convexVertices.remove(this.convexVertices.withData(node.data));\n    } else {\n      this.reflexVertices.remove(this.reflexVertices.withData(node.data));\n    }\n    this.vertices.remove(node);\n    // Deal with previous vertex's change of class\n    if (prevWasConvex != prev.data.isConvex(this)) {\n      if (prevWasConvex) {\n        this.convexVertices.remove(this.convexVertices.withData(prev.data));\n        this.reflexVertices.append(new LinkedList.Node(prev.data));\n      } else {\n        this.reflexVertices.remove(this.reflexVertices.withData(prev.data));\n        this.convexVertices.append(new LinkedList.Node(prev.data));\n      }\n    }\n    // Deal with next vertex's change of class\n    if (nextWasConvex != next.data.isConvex(this)) {\n      if (nextWasConvex) {\n        this.convexVertices.remove(this.convexVertices.withData(next.data));\n        this.reflexVertices.append(new LinkedList.Node(next.data));\n      } else {\n        this.reflexVertices.remove(this.reflexVertices.withData(next.data));\n        this.convexVertices.append(new LinkedList.Node(next.data));\n      }\n    }\n    return this;\n  },\n\n  // Returns true iff the point is strictly inside the polygon\n  contains: function(point) {\n    return this.containsByWindingNumber(point);\n  },\n\n  // Returns true iff the given point is strictly inside the polygon using the winding number method\n  containsByWindingNumber: function(point) {\n    var P = point.elements || point;\n    if (!this.plane.contains(P)) { return false; }\n    if (this.hasEdgeContaining(P)) { return false; }\n    var V, W, A, B, theta = 0, dt, loops = 0, self = this;\n    this.vertices.each(function(node) {\n      V = node.data.elements;\n      W = node.next.data.elements;\n      A = Vector.create([V[0] - P[0], V[1] - P[1], V[2] - (P[2] || 0)]);\n      B = Vector.create([W[0] - P[0], W[1] - P[1], W[2] - (P[2] || 0)]);\n      dt = A.angleFrom(B);\n      if (dt === null || dt === 0) { return; }\n      theta += (A.cross(B).isParallelTo(self.plane.normal) ? 1 : -1) * dt;\n      if (theta >= 2 * Math.PI - Sylvester.precision) { loops++; theta -= 2 * Math.PI; }\n      if (theta <= -2 * Math.PI + Sylvester.precision) { loops--; theta += 2 * Math.PI; }\n    });\n    return loops != 0;\n  },\n\n  // Returns true if the given point lies on an edge of the polygon\n  // May cause problems with 'hole-joining' edges\n  hasEdgeContaining: function(point) {\n    var P = (point.elements || point);\n    var success = false;\n    this.vertices.each(function(node) {\n      if (Line.Segment.create(node.data, node.next.data).contains(P)) { success = true; }\n    });\n    return success;\n  },\n\n  // Returns an array of 3-vertex polygons that the original has been split into\n  // Stores the first calculation for faster retrieval later on\n  toTriangles: function() {\n    if (this.cached.triangles !== null) { return this.cached.triangles; }\n    return this.setCache('triangles', this.triangulateByEarClipping());\n  },\n\n  // Implementation of ear clipping algorithm\n  // Found in 'Triangulation by ear clipping', by David Eberly\n  // at http://www.geometrictools.com\n  // This will not deal with overlapping sections - contruct your polygons sensibly\n  triangulateByEarClipping: function() {\n    var poly = this.dup(), triangles = [], success, convexNode, mainNode, trig;\n    while (!poly.isTriangle()) {\n      success = false;\n      while (!success) {\n        success = true;\n        // Ear tips must be convex vertices - let's pick one at random\n        convexNode = poly.convexVertices.randomNode();\n        mainNode = poly.vertices.withData(convexNode.data);\n        // For convex vertices, this order will always be anticlockwise\n        trig = Polygon.create([mainNode.data, mainNode.next.data, mainNode.prev.data], this.plane);\n        // Now test whether any reflex vertices lie within the ear\n        poly.reflexVertices.each(function(node) {\n          // Don't test points belonging to this triangle. node won't be\n          // equal to convexNode as node is reflex and vertex is convex.\n          if (node.data != mainNode.prev.data && node.data != mainNode.next.data) {\n            if (trig.contains(node.data) || trig.hasEdgeContaining(node.data)) { success = false; }\n          }\n        });\n      }\n      triangles.push(trig);\n      poly.removeVertex(mainNode.data);\n    }\n    // Need to do this to renumber the remaining vertices\n    triangles.push(Polygon.create(poly.vertices, this.plane));\n    return triangles;\n  },\n\n  // Sets the polygon's vertices\n  setVertices: function(points, plane) {\n    var pointSet = points.toArray ? points.toArray() : points;\n    this.plane = (plane && plane.normal) ? plane.dup() : Plane.fromPoints(pointSet);\n    if (this.plane === null) { return null; }\n    this.vertices = new LinkedList.Circular();\n    // Construct linked list of vertices. If each point is already a polygon\n    // vertex, we reference it rather than creating a new vertex.\n    var i = pointSet.length, newVertex;\n    while (i--) {\n      newVertex = pointSet[i].isConvex ? pointSet[i] : new Polygon.Vertex(pointSet[i]);\n      this.vertices.prepend(new LinkedList.Node(newVertex));\n    }\n    this.clearCache();\n    this.populateVertexTypeLists();\n    return this;\n  },\n\n  // Constructs lists of convex and reflex vertices based on the main vertex list.\n  populateVertexTypeLists: function() {\n    this.convexVertices = new LinkedList.Circular();\n    this.reflexVertices = new LinkedList.Circular();\n    var self = this;\n    this.vertices.each(function(node) {\n      // Split vertices into convex / reflex groups\n      // The LinkedList.Node class wraps each vertex so it can belong to many linked lists.\n      self[node.data.type(self) + 'Vertices'].append(new LinkedList.Node(node.data));\n    });\n  },\n\n  // Gives the polygon its own local set of vertex points, allowing it to be\n  // transformed independently of polygons it may be sharing vertices with.\n  copyVertices: function() {\n    this.clearCache();\n    this.vertices.each(function(node) {\n      node.data = new Polygon.Vertex(node.data);\n    });\n    this.populateVertexTypeLists();\n  },\n\n  // Clear any cached properties\n  clearCache: function() {\n    this.cached = {\n      triangles: null,\n      surfaceIntegralElements: null\n    };\n  },\n\n  // Set cached value and return the value\n  setCache: function(key, value) {\n    this.cached[key] = value;\n    return value;\n  },\n\n  // Returns a string representation of the polygon's vertices.\n  inspect: function() {\n    var points = [];\n    this.vertices.each(function(node) { points.push(node.data.inspect()); });\n    return points.join(' -> ');\n  }\n};\n\n// Constructor function\nPolygon.create = function(points, plane) {\n  var P = new Polygon();\n  return P.setVertices(points, plane);\n};\n\nmodule.exports = Polygon;\n","/home/travis/build/npmtest/node-npmtest-sylvester/node_modules/sylvester/lib/node-sylvester/polygon.vertex.js":"// Copyright (c) 2011, Chris Umbel, James Coglan\n// Polygon.Vertex class - required for Polygon class.\n\nvar Sylvester = require('./sylvester');\n\nPolygon.Vertex = function(point) {\n  this.setElements(point);\n  if (this.elements.length == 2) { this.elements.push(0); }\n  if (this.elements.length != 3) { return null; }\n};\nPolygon.Vertex.prototype = new Vector;\n\n// Returns true iff the vertex's internal angle is 0 <= x < 180\n// in the context of the given polygon object. Returns null if the\n// vertex does not exist in the polygon.\nPolygon.Vertex.prototype.isConvex = function(polygon) {\n  var node = polygon.nodeFor(this);\n  if (node === null) { return null; }\n  var prev = node.prev.data, next = node.next.data;\n  var A = next.subtract(this);\n  var B = prev.subtract(this);\n  var theta = A.angleFrom(B);\n  if (theta <= Sylvester.precision) { return true; }\n  if (Math.abs(theta - Math.PI) <= Sylvester.precision) { return false; }\n  return (A.cross(B).dot(polygon.plane.normal) > 0);\n};\n// Returns true iff the vertex's internal angle is 180 <= x < 360\nPolygon.Vertex.prototype.isReflex = function(polygon) {\n  var result = this.isConvex(polygon);\n  return (result === null) ? null : !result;\n};\nPolygon.Vertex.prototype.type = function(polygon) {\n  var result = this.isConvex(polygon);\n  return (result === null) ? null : (result ? 'convex' : 'reflex');\n};\n\n// Method for converting a set of arrays/vectors/whatever to a set of Polygon.Vertex objects\nPolygon.Vertex.convert = function(points) {\n  var pointSet = points.toArray ? points.toArray() : points;\n  var list = [], n = pointSet.length;\n  for (var i = 0; i < n; i++) {\n    list.push(new Polygon.Vertex(pointSet[i]));\n  }\n  return list;\n};\n\nmodule.exports = Polygon.Vertex;\n"}